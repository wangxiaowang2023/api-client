# coding: utf-8

"""
    HTTP API Console

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class QueryApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def cosmos_auth_v1_beta1_account(self, address, **kwargs):  # noqa: E501
        """Account returns account details based on address.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_account(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address defines the address to query for. (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_auth_v1_beta1_account_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_auth_v1_beta1_account_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def cosmos_auth_v1_beta1_account_with_http_info(self, address, **kwargs):  # noqa: E501
        """Account returns account details based on address.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_account_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address defines the address to query for. (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_auth_v1_beta1_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `cosmos_auth_v1_beta1_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/auth/v1beta1/accounts/{address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_auth_v1_beta1_account_address_by_id(self, id, **kwargs):  # noqa: E501
        """AccountAddressByID returns account address based on account number.  # noqa: E501

        Since: cosmos-sdk 0.46.2  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_account_address_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Deprecated, use account_id instead  id is the account number of the address to be queried. This field should have been an uint64 (like all account numbers), and will be updated to uint64 in a future version of the auth query. (required)
        :param str account_id: account_id is the account number of the address to be queried.  Since: cosmos-sdk 0.47
        :return: QueryAccountAddressByIDResponseIsTheResponseTypeForAccountAddressByIDRpcMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_auth_v1_beta1_account_address_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_auth_v1_beta1_account_address_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def cosmos_auth_v1_beta1_account_address_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """AccountAddressByID returns account address based on account number.  # noqa: E501

        Since: cosmos-sdk 0.46.2  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_account_address_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Deprecated, use account_id instead  id is the account number of the address to be queried. This field should have been an uint64 (like all account numbers), and will be updated to uint64 in a future version of the auth query. (required)
        :param str account_id: account_id is the account number of the address to be queried.  Since: cosmos-sdk 0.47
        :return: QueryAccountAddressByIDResponseIsTheResponseTypeForAccountAddressByIDRpcMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_auth_v1_beta1_account_address_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `cosmos_auth_v1_beta1_account_address_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/auth/v1beta1/address_by_id/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryAccountAddressByIDResponseIsTheResponseTypeForAccountAddressByIDRpcMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_auth_v1_beta1_account_info(self, address, **kwargs):  # noqa: E501
        """AccountInfo queries account info which is common to all account types.  # noqa: E501

        Since: cosmos-sdk 0.47  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_account_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the account address string. (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_auth_v1_beta1_account_info_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_auth_v1_beta1_account_info_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def cosmos_auth_v1_beta1_account_info_with_http_info(self, address, **kwargs):  # noqa: E501
        """AccountInfo queries account info which is common to all account types.  # noqa: E501

        Since: cosmos-sdk 0.47  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_account_info_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the account address string. (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_auth_v1_beta1_account_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `cosmos_auth_v1_beta1_account_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/auth/v1beta1/account_info/{address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_auth_v1_beta1_accounts(self, **kwargs):  # noqa: E501
        """Accounts returns all the existing accounts.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  Since: cosmos-sdk 0.43  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_accounts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_auth_v1_beta1_accounts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_auth_v1_beta1_accounts_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_auth_v1_beta1_accounts_with_http_info(self, **kwargs):  # noqa: E501
        """Accounts returns all the existing accounts.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  Since: cosmos-sdk 0.43  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_accounts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_auth_v1_beta1_accounts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/auth/v1beta1/accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_auth_v1_beta1_address_bytes_to_string(self, address_bytes, **kwargs):  # noqa: E501
        """AddressBytesToString converts Account Address bytes to string  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_address_bytes_to_string(address_bytes, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address_bytes: (required)
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_auth_v1_beta1_address_bytes_to_string_with_http_info(address_bytes, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_auth_v1_beta1_address_bytes_to_string_with_http_info(address_bytes, **kwargs)  # noqa: E501
            return data

    def cosmos_auth_v1_beta1_address_bytes_to_string_with_http_info(self, address_bytes, **kwargs):  # noqa: E501
        """AddressBytesToString converts Account Address bytes to string  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_address_bytes_to_string_with_http_info(address_bytes, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address_bytes: (required)
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address_bytes']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_auth_v1_beta1_address_bytes_to_string" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address_bytes' is set
        if ('address_bytes' not in params or
                params['address_bytes'] is None):
            raise ValueError("Missing the required parameter `address_bytes` when calling `cosmos_auth_v1_beta1_address_bytes_to_string`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address_bytes' in params:
            path_params['address_bytes'] = params['address_bytes']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/auth/v1beta1/bech32/{address_bytes}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_auth_v1_beta1_address_string_to_bytes(self, address_string, **kwargs):  # noqa: E501
        """AddressStringToBytes converts Address string to bytes  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_address_string_to_bytes(address_string, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address_string: (required)
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_auth_v1_beta1_address_string_to_bytes_with_http_info(address_string, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_auth_v1_beta1_address_string_to_bytes_with_http_info(address_string, **kwargs)  # noqa: E501
            return data

    def cosmos_auth_v1_beta1_address_string_to_bytes_with_http_info(self, address_string, **kwargs):  # noqa: E501
        """AddressStringToBytes converts Address string to bytes  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_address_string_to_bytes_with_http_info(address_string, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address_string: (required)
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address_string']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_auth_v1_beta1_address_string_to_bytes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address_string' is set
        if ('address_string' not in params or
                params['address_string'] is None):
            raise ValueError("Missing the required parameter `address_string` when calling `cosmos_auth_v1_beta1_address_string_to_bytes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address_string' in params:
            path_params['address_string'] = params['address_string']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/auth/v1beta1/bech32/{address_string}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_auth_v1_beta1_bech32_prefix(self, **kwargs):  # noqa: E501
        """Bech32Prefix queries bech32Prefix  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_bech32_prefix(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_auth_v1_beta1_bech32_prefix_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_auth_v1_beta1_bech32_prefix_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_auth_v1_beta1_bech32_prefix_with_http_info(self, **kwargs):  # noqa: E501
        """Bech32Prefix queries bech32Prefix  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_bech32_prefix_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_auth_v1_beta1_bech32_prefix" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/auth/v1beta1/bech32', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_auth_v1_beta1_module_account_by_name(self, name, **kwargs):  # noqa: E501
        """ModuleAccountByName returns the module account info by module name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_module_account_by_name(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_auth_v1_beta1_module_account_by_name_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_auth_v1_beta1_module_account_by_name_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def cosmos_auth_v1_beta1_module_account_by_name_with_http_info(self, name, **kwargs):  # noqa: E501
        """ModuleAccountByName returns the module account info by module name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_module_account_by_name_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_auth_v1_beta1_module_account_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `cosmos_auth_v1_beta1_module_account_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/auth/v1beta1/module_accounts/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_auth_v1_beta1_module_accounts(self, **kwargs):  # noqa: E501
        """ModuleAccounts returns all the existing module accounts.  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_module_accounts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_auth_v1_beta1_module_accounts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_auth_v1_beta1_module_accounts_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_auth_v1_beta1_module_accounts_with_http_info(self, **kwargs):  # noqa: E501
        """ModuleAccounts returns all the existing module accounts.  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_module_accounts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_auth_v1_beta1_module_accounts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/auth/v1beta1/module_accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_auth_v1_beta1_params(self, **kwargs):  # noqa: E501
        """Params queries all parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_auth_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_auth_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_auth_v1_beta1_params_with_http_info(self, **kwargs):  # noqa: E501
        """Params queries all parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_auth_v1_beta1_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_auth_v1_beta1_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/auth/v1beta1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_authz_v1_beta1_grantee_grants(self, grantee, **kwargs):  # noqa: E501
        """GranteeGrants returns a list of `GrantAuthorization` by grantee.  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_authz_v1_beta1_grantee_grants(grantee, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grantee: (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_authz_v1_beta1_grantee_grants_with_http_info(grantee, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_authz_v1_beta1_grantee_grants_with_http_info(grantee, **kwargs)  # noqa: E501
            return data

    def cosmos_authz_v1_beta1_grantee_grants_with_http_info(self, grantee, **kwargs):  # noqa: E501
        """GranteeGrants returns a list of `GrantAuthorization` by grantee.  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_authz_v1_beta1_grantee_grants_with_http_info(grantee, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grantee: (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['grantee', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_authz_v1_beta1_grantee_grants" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'grantee' is set
        if ('grantee' not in params or
                params['grantee'] is None):
            raise ValueError("Missing the required parameter `grantee` when calling `cosmos_authz_v1_beta1_grantee_grants`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'grantee' in params:
            path_params['grantee'] = params['grantee']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/authz/v1beta1/grants/grantee/{grantee}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_authz_v1_beta1_granter_grants(self, granter, **kwargs):  # noqa: E501
        """GranterGrants returns list of `GrantAuthorization`, granted by granter.  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_authz_v1_beta1_granter_grants(granter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str granter: (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_authz_v1_beta1_granter_grants_with_http_info(granter, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_authz_v1_beta1_granter_grants_with_http_info(granter, **kwargs)  # noqa: E501
            return data

    def cosmos_authz_v1_beta1_granter_grants_with_http_info(self, granter, **kwargs):  # noqa: E501
        """GranterGrants returns list of `GrantAuthorization`, granted by granter.  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_authz_v1_beta1_granter_grants_with_http_info(granter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str granter: (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['granter', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_authz_v1_beta1_granter_grants" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'granter' is set
        if ('granter' not in params or
                params['granter'] is None):
            raise ValueError("Missing the required parameter `granter` when calling `cosmos_authz_v1_beta1_granter_grants`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'granter' in params:
            path_params['granter'] = params['granter']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/authz/v1beta1/grants/granter/{granter}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_authz_v1_beta1_grants(self, **kwargs):  # noqa: E501
        """Returns list of `Authorization`, granted to the grantee by the granter.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_authz_v1_beta1_grants(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str granter:
        :param str grantee:
        :param str msg_type_url: Optional, msg_type_url, when set, will query only grants matching given msg type.
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_authz_v1_beta1_grants_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_authz_v1_beta1_grants_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_authz_v1_beta1_grants_with_http_info(self, **kwargs):  # noqa: E501
        """Returns list of `Authorization`, granted to the grantee by the granter.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_authz_v1_beta1_grants_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str granter:
        :param str grantee:
        :param str msg_type_url: Optional, msg_type_url, when set, will query only grants matching given msg type.
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['granter', 'grantee', 'msg_type_url', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_authz_v1_beta1_grants" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'granter' in params:
            query_params.append(('granter', params['granter']))  # noqa: E501
        if 'grantee' in params:
            query_params.append(('grantee', params['grantee']))  # noqa: E501
        if 'msg_type_url' in params:
            query_params.append(('msg_type_url', params['msg_type_url']))  # noqa: E501
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/authz/v1beta1/grants', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_bank_v1_beta1_all_balances(self, address, **kwargs):  # noqa: E501
        """AllBalances queries the balance of all coins for a single account.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_all_balances(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address to query balances for. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_bank_v1_beta1_all_balances_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_bank_v1_beta1_all_balances_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def cosmos_bank_v1_beta1_all_balances_with_http_info(self, address, **kwargs):  # noqa: E501
        """AllBalances queries the balance of all coins for a single account.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_all_balances_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address to query balances for. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_bank_v1_beta1_all_balances" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `cosmos_bank_v1_beta1_all_balances`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/bank/v1beta1/balances/{address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_bank_v1_beta1_balance(self, address, **kwargs):  # noqa: E501
        """Balance queries the balance of a single coin for a single account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_balance(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address to query balances for. (required)
        :param str denom: denom is the coin denom to query balances for.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_bank_v1_beta1_balance_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_bank_v1_beta1_balance_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def cosmos_bank_v1_beta1_balance_with_http_info(self, address, **kwargs):  # noqa: E501
        """Balance queries the balance of a single coin for a single account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_balance_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address to query balances for. (required)
        :param str denom: denom is the coin denom to query balances for.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'denom']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_bank_v1_beta1_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `cosmos_bank_v1_beta1_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'denom' in params:
            query_params.append(('denom', params['denom']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/bank/v1beta1/balances/{address}/by_denom', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_bank_v1_beta1_denom_metadata(self, denom, **kwargs):  # noqa: E501
        """DenomsMetadata queries the client metadata of a given coin denomination.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_denom_metadata(denom, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str denom: denom is the coin denom to query the metadata for. (required)
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_bank_v1_beta1_denom_metadata_with_http_info(denom, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_bank_v1_beta1_denom_metadata_with_http_info(denom, **kwargs)  # noqa: E501
            return data

    def cosmos_bank_v1_beta1_denom_metadata_with_http_info(self, denom, **kwargs):  # noqa: E501
        """DenomsMetadata queries the client metadata of a given coin denomination.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_denom_metadata_with_http_info(denom, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str denom: denom is the coin denom to query the metadata for. (required)
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['denom']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_bank_v1_beta1_denom_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'denom' is set
        if ('denom' not in params or
                params['denom'] is None):
            raise ValueError("Missing the required parameter `denom` when calling `cosmos_bank_v1_beta1_denom_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'denom' in params:
            path_params['denom'] = params['denom']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/bank/v1beta1/denoms_metadata/{denom}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_bank_v1_beta1_denom_owners(self, denom, **kwargs):  # noqa: E501
        """DenomOwners queries for all account addresses that own a particular token denomination.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_denom_owners(denom, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str denom: denom defines the coin denomination to query all account holders for. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_bank_v1_beta1_denom_owners_with_http_info(denom, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_bank_v1_beta1_denom_owners_with_http_info(denom, **kwargs)  # noqa: E501
            return data

    def cosmos_bank_v1_beta1_denom_owners_with_http_info(self, denom, **kwargs):  # noqa: E501
        """DenomOwners queries for all account addresses that own a particular token denomination.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_denom_owners_with_http_info(denom, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str denom: denom defines the coin denomination to query all account holders for. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['denom', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_bank_v1_beta1_denom_owners" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'denom' is set
        if ('denom' not in params or
                params['denom'] is None):
            raise ValueError("Missing the required parameter `denom` when calling `cosmos_bank_v1_beta1_denom_owners`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'denom' in params:
            path_params['denom'] = params['denom']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/bank/v1beta1/denom_owners/{denom}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_bank_v1_beta1_denoms_metadata(self, **kwargs):  # noqa: E501
        """DenomsMetadata queries the client metadata for all registered coin denominations.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_denoms_metadata(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_bank_v1_beta1_denoms_metadata_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_bank_v1_beta1_denoms_metadata_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_bank_v1_beta1_denoms_metadata_with_http_info(self, **kwargs):  # noqa: E501
        """DenomsMetadata queries the client metadata for all registered coin denominations.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_denoms_metadata_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_bank_v1_beta1_denoms_metadata" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/bank/v1beta1/denoms_metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20015',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_bank_v1_beta1_params(self, **kwargs):  # noqa: E501
        """Params queries the parameters of x/bank module.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_bank_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_bank_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_bank_v1_beta1_params_with_http_info(self, **kwargs):  # noqa: E501
        """Params queries the parameters of x/bank module.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_bank_v1_beta1_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/bank/v1beta1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_bank_v1_beta1_send_enabled(self, **kwargs):  # noqa: E501
        """SendEnabled queries for SendEnabled entries.  # noqa: E501

        This query only returns denominations that have specific SendEnabled settings. Any denomination that does not have a specific setting will use the default params.default_send_enabled, and will not be returned by this query.  Since: cosmos-sdk 0.47  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_send_enabled(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] denoms: denoms is the specific denoms you want look up. Leave empty to get all entries.
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_bank_v1_beta1_send_enabled_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_bank_v1_beta1_send_enabled_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_bank_v1_beta1_send_enabled_with_http_info(self, **kwargs):  # noqa: E501
        """SendEnabled queries for SendEnabled entries.  # noqa: E501

        This query only returns denominations that have specific SendEnabled settings. Any denomination that does not have a specific setting will use the default params.default_send_enabled, and will not be returned by this query.  Since: cosmos-sdk 0.47  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_send_enabled_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] denoms: denoms is the specific denoms you want look up. Leave empty to get all entries.
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['denoms', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_bank_v1_beta1_send_enabled" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'denoms' in params:
            query_params.append(('denoms', params['denoms']))  # noqa: E501
            collection_formats['denoms'] = 'multi'  # noqa: E501
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/bank/v1beta1/send_enabled', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_bank_v1_beta1_spendable_balance_by_denom(self, address, **kwargs):  # noqa: E501
        """SpendableBalanceByDenom queries the spendable balance of a single denom for a single account.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  Since: cosmos-sdk 0.47  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_spendable_balance_by_denom(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address to query balances for. (required)
        :param str denom: denom is the coin denom to query balances for.
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_bank_v1_beta1_spendable_balance_by_denom_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_bank_v1_beta1_spendable_balance_by_denom_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def cosmos_bank_v1_beta1_spendable_balance_by_denom_with_http_info(self, address, **kwargs):  # noqa: E501
        """SpendableBalanceByDenom queries the spendable balance of a single denom for a single account.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  Since: cosmos-sdk 0.47  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_spendable_balance_by_denom_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address to query balances for. (required)
        :param str denom: denom is the coin denom to query balances for.
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'denom']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_bank_v1_beta1_spendable_balance_by_denom" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `cosmos_bank_v1_beta1_spendable_balance_by_denom`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'denom' in params:
            query_params.append(('denom', params['denom']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/bank/v1beta1/spendable_balances/{address}/by_denom', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20020',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_bank_v1_beta1_spendable_balances(self, address, **kwargs):  # noqa: E501
        """SpendableBalances queries the spendable balance of all coins for a single account.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_spendable_balances(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address to query spendable balances for. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_bank_v1_beta1_spendable_balances_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_bank_v1_beta1_spendable_balances_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def cosmos_bank_v1_beta1_spendable_balances_with_http_info(self, address, **kwargs):  # noqa: E501
        """SpendableBalances queries the spendable balance of all coins for a single account.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_spendable_balances_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address to query spendable balances for. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_bank_v1_beta1_spendable_balances" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `cosmos_bank_v1_beta1_spendable_balances`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/bank/v1beta1/spendable_balances/{address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_bank_v1_beta1_supply_of(self, **kwargs):  # noqa: E501
        """SupplyOf queries the supply of a single coin.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_supply_of(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str denom: denom is the coin denom to query balances for.
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_bank_v1_beta1_supply_of_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_bank_v1_beta1_supply_of_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_bank_v1_beta1_supply_of_with_http_info(self, **kwargs):  # noqa: E501
        """SupplyOf queries the supply of a single coin.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_supply_of_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str denom: denom is the coin denom to query balances for.
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['denom']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_bank_v1_beta1_supply_of" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'denom' in params:
            query_params.append(('denom', params['denom']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/bank/v1beta1/supply/by_denom', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_bank_v1_beta1_total_supply(self, **kwargs):  # noqa: E501
        """TotalSupply queries the total supply of all coins.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_total_supply(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCmethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_bank_v1_beta1_total_supply_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_bank_v1_beta1_total_supply_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_bank_v1_beta1_total_supply_with_http_info(self, **kwargs):  # noqa: E501
        """TotalSupply queries the total supply of all coins.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_bank_v1_beta1_total_supply_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCmethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_bank_v1_beta1_total_supply" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/bank/v1beta1/supply', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCmethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_consensus_v1_params(self, **kwargs):  # noqa: E501
        """Params queries the parameters of x/consensus_param module.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_consensus_v1_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_consensus_v1_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_consensus_v1_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_consensus_v1_params_with_http_info(self, **kwargs):  # noqa: E501
        """Params queries the parameters of x/consensus_param module.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_consensus_v1_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_consensus_v1_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/consensus/v1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20030',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_distribution_v1_beta1_delegation_rewards(self, delegator_address, validator_address, **kwargs):  # noqa: E501
        """DelegationRewards queries the total rewards accrued by a delegation.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_distribution_v1_beta1_delegation_rewards(delegator_address, validator_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delegator_address: delegator_address defines the delegator address to query for. (required)
        :param str validator_address: validator_address defines the validator address to query for. (required)
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_distribution_v1_beta1_delegation_rewards_with_http_info(delegator_address, validator_address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_distribution_v1_beta1_delegation_rewards_with_http_info(delegator_address, validator_address, **kwargs)  # noqa: E501
            return data

    def cosmos_distribution_v1_beta1_delegation_rewards_with_http_info(self, delegator_address, validator_address, **kwargs):  # noqa: E501
        """DelegationRewards queries the total rewards accrued by a delegation.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_distribution_v1_beta1_delegation_rewards_with_http_info(delegator_address, validator_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delegator_address: delegator_address defines the delegator address to query for. (required)
        :param str validator_address: validator_address defines the validator address to query for. (required)
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delegator_address', 'validator_address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_distribution_v1_beta1_delegation_rewards" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delegator_address' is set
        if ('delegator_address' not in params or
                params['delegator_address'] is None):
            raise ValueError("Missing the required parameter `delegator_address` when calling `cosmos_distribution_v1_beta1_delegation_rewards`")  # noqa: E501
        # verify the required parameter 'validator_address' is set
        if ('validator_address' not in params or
                params['validator_address'] is None):
            raise ValueError("Missing the required parameter `validator_address` when calling `cosmos_distribution_v1_beta1_delegation_rewards`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'delegator_address' in params:
            path_params['delegator_address'] = params['delegator_address']  # noqa: E501
        if 'validator_address' in params:
            path_params['validator_address'] = params['validator_address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20031',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_distribution_v1_beta1_params(self, **kwargs):  # noqa: E501
        """Params queries params of the distribution module.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_distribution_v1_beta1_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_distribution_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_distribution_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_distribution_v1_beta1_params_with_http_info(self, **kwargs):  # noqa: E501
        """Params queries params of the distribution module.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_distribution_v1_beta1_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_distribution_v1_beta1_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/distribution/v1beta1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20032',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_distribution_v1_beta1_validator_distribution_info(self, validator_address, **kwargs):  # noqa: E501
        """ValidatorDistributionInfo queries validator commission and self-delegation rewards for validator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_distribution_v1_beta1_validator_distribution_info(validator_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str validator_address: validator_address defines the validator address to query for. (required)
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_distribution_v1_beta1_validator_distribution_info_with_http_info(validator_address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_distribution_v1_beta1_validator_distribution_info_with_http_info(validator_address, **kwargs)  # noqa: E501
            return data

    def cosmos_distribution_v1_beta1_validator_distribution_info_with_http_info(self, validator_address, **kwargs):  # noqa: E501
        """ValidatorDistributionInfo queries validator commission and self-delegation rewards for validator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_distribution_v1_beta1_validator_distribution_info_with_http_info(validator_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str validator_address: validator_address defines the validator address to query for. (required)
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['validator_address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_distribution_v1_beta1_validator_distribution_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'validator_address' is set
        if ('validator_address' not in params or
                params['validator_address'] is None):
            raise ValueError("Missing the required parameter `validator_address` when calling `cosmos_distribution_v1_beta1_validator_distribution_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'validator_address' in params:
            path_params['validator_address'] = params['validator_address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/distribution/v1beta1/validators/{validator_address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20033',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_evidence_v1_beta1_all_evidence(self, **kwargs):  # noqa: E501
        """AllEvidence queries all evidence.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_evidence_v1_beta1_all_evidence(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_evidence_v1_beta1_all_evidence_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_evidence_v1_beta1_all_evidence_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_evidence_v1_beta1_all_evidence_with_http_info(self, **kwargs):  # noqa: E501
        """AllEvidence queries all evidence.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_evidence_v1_beta1_all_evidence_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_evidence_v1_beta1_all_evidence" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/evidence/v1beta1/evidence', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20034',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_evidence_v1_beta1_evidence(self, hash, **kwargs):  # noqa: E501
        """Evidence queries evidence based on evidence hash.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_evidence_v1_beta1_evidence(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: hash defines the evidence hash of the requested evidence.  Since: cosmos-sdk 0.47 (required)
        :param str evidence_hash: evidence_hash defines the hash of the requested evidence. Deprecated: Use hash, a HEX encoded string, instead.
        :return: InlineResponse20035
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_evidence_v1_beta1_evidence_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_evidence_v1_beta1_evidence_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def cosmos_evidence_v1_beta1_evidence_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Evidence queries evidence based on evidence hash.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_evidence_v1_beta1_evidence_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: hash defines the evidence hash of the requested evidence.  Since: cosmos-sdk 0.47 (required)
        :param str evidence_hash: evidence_hash defines the hash of the requested evidence. Deprecated: Use hash, a HEX encoded string, instead.
        :return: InlineResponse20035
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'evidence_hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_evidence_v1_beta1_evidence" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `cosmos_evidence_v1_beta1_evidence`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'evidence_hash' in params:
            query_params.append(('evidence_hash', params['evidence_hash']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/evidence/v1beta1/evidence/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20035',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_feegrant_v1_beta1_allowance(self, granter, grantee, **kwargs):  # noqa: E501
        """Allowance returns fee granted to the grantee by the granter.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_feegrant_v1_beta1_allowance(granter, grantee, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str granter: granter is the address of the user granting an allowance of their funds. (required)
        :param str grantee: grantee is the address of the user being granted an allowance of another user's funds. (required)
        :return: InlineResponse20036
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_feegrant_v1_beta1_allowance_with_http_info(granter, grantee, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_feegrant_v1_beta1_allowance_with_http_info(granter, grantee, **kwargs)  # noqa: E501
            return data

    def cosmos_feegrant_v1_beta1_allowance_with_http_info(self, granter, grantee, **kwargs):  # noqa: E501
        """Allowance returns fee granted to the grantee by the granter.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_feegrant_v1_beta1_allowance_with_http_info(granter, grantee, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str granter: granter is the address of the user granting an allowance of their funds. (required)
        :param str grantee: grantee is the address of the user being granted an allowance of another user's funds. (required)
        :return: InlineResponse20036
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['granter', 'grantee']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_feegrant_v1_beta1_allowance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'granter' is set
        if ('granter' not in params or
                params['granter'] is None):
            raise ValueError("Missing the required parameter `granter` when calling `cosmos_feegrant_v1_beta1_allowance`")  # noqa: E501
        # verify the required parameter 'grantee' is set
        if ('grantee' not in params or
                params['grantee'] is None):
            raise ValueError("Missing the required parameter `grantee` when calling `cosmos_feegrant_v1_beta1_allowance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'granter' in params:
            path_params['granter'] = params['granter']  # noqa: E501
        if 'grantee' in params:
            path_params['grantee'] = params['grantee']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20036',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_feegrant_v1_beta1_allowances(self, grantee, **kwargs):  # noqa: E501
        """Allowances returns all the grants for address.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_feegrant_v1_beta1_allowances(grantee, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grantee: (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20037
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_feegrant_v1_beta1_allowances_with_http_info(grantee, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_feegrant_v1_beta1_allowances_with_http_info(grantee, **kwargs)  # noqa: E501
            return data

    def cosmos_feegrant_v1_beta1_allowances_with_http_info(self, grantee, **kwargs):  # noqa: E501
        """Allowances returns all the grants for address.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_feegrant_v1_beta1_allowances_with_http_info(grantee, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grantee: (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20037
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['grantee', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_feegrant_v1_beta1_allowances" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'grantee' is set
        if ('grantee' not in params or
                params['grantee'] is None):
            raise ValueError("Missing the required parameter `grantee` when calling `cosmos_feegrant_v1_beta1_allowances`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'grantee' in params:
            path_params['grantee'] = params['grantee']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/feegrant/v1beta1/allowances/{grantee}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20037',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_feegrant_v1_beta1_allowances_by_granter(self, granter, **kwargs):  # noqa: E501
        """AllowancesByGranter returns all the grants given by an address  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_feegrant_v1_beta1_allowances_by_granter(granter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str granter: (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_feegrant_v1_beta1_allowances_by_granter_with_http_info(granter, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_feegrant_v1_beta1_allowances_by_granter_with_http_info(granter, **kwargs)  # noqa: E501
            return data

    def cosmos_feegrant_v1_beta1_allowances_by_granter_with_http_info(self, granter, **kwargs):  # noqa: E501
        """AllowancesByGranter returns all the grants given by an address  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_feegrant_v1_beta1_allowances_by_granter_with_http_info(granter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str granter: (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['granter', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_feegrant_v1_beta1_allowances_by_granter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'granter' is set
        if ('granter' not in params or
                params['granter'] is None):
            raise ValueError("Missing the required parameter `granter` when calling `cosmos_feegrant_v1_beta1_allowances_by_granter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'granter' in params:
            path_params['granter'] = params['granter']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/feegrant/v1beta1/issued/{granter}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20038',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_beta1_deposit(self, proposal_id, depositor, **kwargs):  # noqa: E501
        """Deposit queries single deposit information based proposalID, depositAddr.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_deposit(proposal_id, depositor, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str depositor: depositor defines the deposit addresses from the proposals. (required)
        :return: InlineResponse20043
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_beta1_deposit_with_http_info(proposal_id, depositor, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_beta1_deposit_with_http_info(proposal_id, depositor, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_beta1_deposit_with_http_info(self, proposal_id, depositor, **kwargs):  # noqa: E501
        """Deposit queries single deposit information based proposalID, depositAddr.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_deposit_with_http_info(proposal_id, depositor, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str depositor: depositor defines the deposit addresses from the proposals. (required)
        :return: InlineResponse20043
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_id', 'depositor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_beta1_deposit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proposal_id' is set
        if ('proposal_id' not in params or
                params['proposal_id'] is None):
            raise ValueError("Missing the required parameter `proposal_id` when calling `cosmos_gov_v1_beta1_deposit`")  # noqa: E501
        # verify the required parameter 'depositor' is set
        if ('depositor' not in params or
                params['depositor'] is None):
            raise ValueError("Missing the required parameter `depositor` when calling `cosmos_gov_v1_beta1_deposit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proposal_id' in params:
            path_params['proposal_id'] = params['proposal_id']  # noqa: E501
        if 'depositor' in params:
            path_params['depositor'] = params['depositor']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20043',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_beta1_deposits(self, proposal_id, **kwargs):  # noqa: E501
        """Deposits queries all deposits of a single proposal.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_deposits(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20042
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_beta1_deposits_with_http_info(proposal_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_beta1_deposits_with_http_info(proposal_id, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_beta1_deposits_with_http_info(self, proposal_id, **kwargs):  # noqa: E501
        """Deposits queries all deposits of a single proposal.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_deposits_with_http_info(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20042
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_id', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_beta1_deposits" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proposal_id' is set
        if ('proposal_id' not in params or
                params['proposal_id'] is None):
            raise ValueError("Missing the required parameter `proposal_id` when calling `cosmos_gov_v1_beta1_deposits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proposal_id' in params:
            path_params['proposal_id'] = params['proposal_id']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20042',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_beta1_params(self, params_type, **kwargs):  # noqa: E501
        """Params queries all parameters of the gov module.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_params(params_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str params_type: params_type defines which parameters to query for, can be one of \"voting\", \"tallying\" or \"deposit\". (required)
        :return: InlineResponse20047
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_beta1_params_with_http_info(params_type, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_beta1_params_with_http_info(params_type, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_beta1_params_with_http_info(self, params_type, **kwargs):  # noqa: E501
        """Params queries all parameters of the gov module.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_params_with_http_info(params_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str params_type: params_type defines which parameters to query for, can be one of \"voting\", \"tallying\" or \"deposit\". (required)
        :return: InlineResponse20047
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['params_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_beta1_params" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'params_type' is set
        if ('params_type' not in params or
                params['params_type'] is None):
            raise ValueError("Missing the required parameter `params_type` when calling `cosmos_gov_v1_beta1_params`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'params_type' in params:
            path_params['params_type'] = params['params_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1beta1/params/{params_type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20047',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_beta1_proposal(self, proposal_id, **kwargs):  # noqa: E501
        """Proposal queries proposal details based on ProposalID.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_proposal(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :return: InlineResponse20049
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_beta1_proposal_with_http_info(proposal_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_beta1_proposal_with_http_info(proposal_id, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_beta1_proposal_with_http_info(self, proposal_id, **kwargs):  # noqa: E501
        """Proposal queries proposal details based on ProposalID.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_proposal_with_http_info(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :return: InlineResponse20049
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_beta1_proposal" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proposal_id' is set
        if ('proposal_id' not in params or
                params['proposal_id'] is None):
            raise ValueError("Missing the required parameter `proposal_id` when calling `cosmos_gov_v1_beta1_proposal`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proposal_id' in params:
            path_params['proposal_id'] = params['proposal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1beta1/proposals/{proposal_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20049',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_beta1_proposals(self, **kwargs):  # noqa: E501
        """Proposals queries all proposals based on given status.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_proposals(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_status: proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
        :param str voter: voter defines the voter address for the proposals.
        :param str depositor: depositor defines the deposit addresses from the proposals.
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20048
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_beta1_proposals_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_beta1_proposals_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_beta1_proposals_with_http_info(self, **kwargs):  # noqa: E501
        """Proposals queries all proposals based on given status.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_proposals_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_status: proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
        :param str voter: voter defines the voter address for the proposals.
        :param str depositor: depositor defines the deposit addresses from the proposals.
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20048
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_status', 'voter', 'depositor', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_beta1_proposals" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'proposal_status' in params:
            query_params.append(('proposal_status', params['proposal_status']))  # noqa: E501
        if 'voter' in params:
            query_params.append(('voter', params['voter']))  # noqa: E501
        if 'depositor' in params:
            query_params.append(('depositor', params['depositor']))  # noqa: E501
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1beta1/proposals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20048',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_beta1_tally_result(self, proposal_id, **kwargs):  # noqa: E501
        """TallyResult queries the tally of a proposal vote.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_tally_result(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :return: InlineResponse20050
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_beta1_tally_result_with_http_info(proposal_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_beta1_tally_result_with_http_info(proposal_id, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_beta1_tally_result_with_http_info(self, proposal_id, **kwargs):  # noqa: E501
        """TallyResult queries the tally of a proposal vote.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_tally_result_with_http_info(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :return: InlineResponse20050
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_beta1_tally_result" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proposal_id' is set
        if ('proposal_id' not in params or
                params['proposal_id'] is None):
            raise ValueError("Missing the required parameter `proposal_id` when calling `cosmos_gov_v1_beta1_tally_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proposal_id' in params:
            path_params['proposal_id'] = params['proposal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1beta1/proposals/{proposal_id}/tally', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20050',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_beta1_vote(self, proposal_id, voter, **kwargs):  # noqa: E501
        """Vote queries voted information based on proposalID, voterAddr.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_vote(proposal_id, voter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str voter: voter defines the voter address for the proposals. (required)
        :return: InlineResponse20052
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_beta1_vote_with_http_info(proposal_id, voter, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_beta1_vote_with_http_info(proposal_id, voter, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_beta1_vote_with_http_info(self, proposal_id, voter, **kwargs):  # noqa: E501
        """Vote queries voted information based on proposalID, voterAddr.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_vote_with_http_info(proposal_id, voter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str voter: voter defines the voter address for the proposals. (required)
        :return: InlineResponse20052
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_id', 'voter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_beta1_vote" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proposal_id' is set
        if ('proposal_id' not in params or
                params['proposal_id'] is None):
            raise ValueError("Missing the required parameter `proposal_id` when calling `cosmos_gov_v1_beta1_vote`")  # noqa: E501
        # verify the required parameter 'voter' is set
        if ('voter' not in params or
                params['voter'] is None):
            raise ValueError("Missing the required parameter `voter` when calling `cosmos_gov_v1_beta1_vote`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proposal_id' in params:
            path_params['proposal_id'] = params['proposal_id']  # noqa: E501
        if 'voter' in params:
            path_params['voter'] = params['voter']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20052',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_beta1_votes(self, proposal_id, **kwargs):  # noqa: E501
        """Votes queries votes of a given proposal.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_votes(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20051
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_beta1_votes_with_http_info(proposal_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_beta1_votes_with_http_info(proposal_id, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_beta1_votes_with_http_info(self, proposal_id, **kwargs):  # noqa: E501
        """Votes queries votes of a given proposal.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_beta1_votes_with_http_info(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20051
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_id', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_beta1_votes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proposal_id' is set
        if ('proposal_id' not in params or
                params['proposal_id'] is None):
            raise ValueError("Missing the required parameter `proposal_id` when calling `cosmos_gov_v1_beta1_votes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proposal_id' in params:
            path_params['proposal_id'] = params['proposal_id']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1beta1/proposals/{proposal_id}/votes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20051',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_deposit(self, proposal_id, depositor, **kwargs):  # noqa: E501
        """Deposit queries single deposit information based proposalID, depositAddr.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_deposit(proposal_id, depositor, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str depositor: depositor defines the deposit addresses from the proposals. (required)
        :return: InlineResponse20043
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_deposit_with_http_info(proposal_id, depositor, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_deposit_with_http_info(proposal_id, depositor, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_deposit_with_http_info(self, proposal_id, depositor, **kwargs):  # noqa: E501
        """Deposit queries single deposit information based proposalID, depositAddr.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_deposit_with_http_info(proposal_id, depositor, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str depositor: depositor defines the deposit addresses from the proposals. (required)
        :return: InlineResponse20043
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_id', 'depositor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_deposit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proposal_id' is set
        if ('proposal_id' not in params or
                params['proposal_id'] is None):
            raise ValueError("Missing the required parameter `proposal_id` when calling `cosmos_gov_v1_deposit`")  # noqa: E501
        # verify the required parameter 'depositor' is set
        if ('depositor' not in params or
                params['depositor'] is None):
            raise ValueError("Missing the required parameter `depositor` when calling `cosmos_gov_v1_deposit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proposal_id' in params:
            path_params['proposal_id'] = params['proposal_id']  # noqa: E501
        if 'depositor' in params:
            path_params['depositor'] = params['depositor']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1/proposals/{proposal_id}/deposits/{depositor}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20043',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_deposits(self, proposal_id, **kwargs):  # noqa: E501
        """Deposits queries all deposits of a single proposal.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_deposits(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20042
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_deposits_with_http_info(proposal_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_deposits_with_http_info(proposal_id, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_deposits_with_http_info(self, proposal_id, **kwargs):  # noqa: E501
        """Deposits queries all deposits of a single proposal.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_deposits_with_http_info(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20042
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_id', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_deposits" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proposal_id' is set
        if ('proposal_id' not in params or
                params['proposal_id'] is None):
            raise ValueError("Missing the required parameter `proposal_id` when calling `cosmos_gov_v1_deposits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proposal_id' in params:
            path_params['proposal_id'] = params['proposal_id']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1/proposals/{proposal_id}/deposits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20042',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_params(self, params_type, **kwargs):  # noqa: E501
        """Params queries all parameters of the gov module.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_params(params_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str params_type: params_type defines which parameters to query for, can be one of \"voting\", \"tallying\" or \"deposit\". (required)
        :return: InlineResponse20039
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_params_with_http_info(params_type, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_params_with_http_info(params_type, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_params_with_http_info(self, params_type, **kwargs):  # noqa: E501
        """Params queries all parameters of the gov module.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_params_with_http_info(params_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str params_type: params_type defines which parameters to query for, can be one of \"voting\", \"tallying\" or \"deposit\". (required)
        :return: InlineResponse20039
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['params_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_params" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'params_type' is set
        if ('params_type' not in params or
                params['params_type'] is None):
            raise ValueError("Missing the required parameter `params_type` when calling `cosmos_gov_v1_params`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'params_type' in params:
            path_params['params_type'] = params['params_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1/params/{params_type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20039',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_proposal(self, proposal_id, **kwargs):  # noqa: E501
        """Proposal queries proposal details based on ProposalID.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_proposal(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :return: InlineResponse20041
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_proposal_with_http_info(proposal_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_proposal_with_http_info(proposal_id, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_proposal_with_http_info(self, proposal_id, **kwargs):  # noqa: E501
        """Proposal queries proposal details based on ProposalID.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_proposal_with_http_info(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :return: InlineResponse20041
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_proposal" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proposal_id' is set
        if ('proposal_id' not in params or
                params['proposal_id'] is None):
            raise ValueError("Missing the required parameter `proposal_id` when calling `cosmos_gov_v1_proposal`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proposal_id' in params:
            path_params['proposal_id'] = params['proposal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1/proposals/{proposal_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20041',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_proposals(self, **kwargs):  # noqa: E501
        """Proposals queries all proposals based on given status.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_proposals(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_status: proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
        :param str voter: voter defines the voter address for the proposals.
        :param str depositor: depositor defines the deposit addresses from the proposals.
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20040
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_proposals_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_proposals_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_proposals_with_http_info(self, **kwargs):  # noqa: E501
        """Proposals queries all proposals based on given status.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_proposals_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_status: proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
        :param str voter: voter defines the voter address for the proposals.
        :param str depositor: depositor defines the deposit addresses from the proposals.
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20040
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_status', 'voter', 'depositor', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_proposals" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'proposal_status' in params:
            query_params.append(('proposal_status', params['proposal_status']))  # noqa: E501
        if 'voter' in params:
            query_params.append(('voter', params['voter']))  # noqa: E501
        if 'depositor' in params:
            query_params.append(('depositor', params['depositor']))  # noqa: E501
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1/proposals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20040',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_tally_result(self, proposal_id, **kwargs):  # noqa: E501
        """TallyResult queries the tally of a proposal vote.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_tally_result(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :return: InlineResponse20044
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_tally_result_with_http_info(proposal_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_tally_result_with_http_info(proposal_id, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_tally_result_with_http_info(self, proposal_id, **kwargs):  # noqa: E501
        """TallyResult queries the tally of a proposal vote.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_tally_result_with_http_info(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :return: InlineResponse20044
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_tally_result" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proposal_id' is set
        if ('proposal_id' not in params or
                params['proposal_id'] is None):
            raise ValueError("Missing the required parameter `proposal_id` when calling `cosmos_gov_v1_tally_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proposal_id' in params:
            path_params['proposal_id'] = params['proposal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1/proposals/{proposal_id}/tally', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20044',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_vote(self, proposal_id, voter, **kwargs):  # noqa: E501
        """Vote queries voted information based on proposalID, voterAddr.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_vote(proposal_id, voter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str voter: voter defines the voter address for the proposals. (required)
        :return: InlineResponse20046
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_vote_with_http_info(proposal_id, voter, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_vote_with_http_info(proposal_id, voter, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_vote_with_http_info(self, proposal_id, voter, **kwargs):  # noqa: E501
        """Vote queries voted information based on proposalID, voterAddr.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_vote_with_http_info(proposal_id, voter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str voter: voter defines the voter address for the proposals. (required)
        :return: InlineResponse20046
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_id', 'voter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_vote" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proposal_id' is set
        if ('proposal_id' not in params or
                params['proposal_id'] is None):
            raise ValueError("Missing the required parameter `proposal_id` when calling `cosmos_gov_v1_vote`")  # noqa: E501
        # verify the required parameter 'voter' is set
        if ('voter' not in params or
                params['voter'] is None):
            raise ValueError("Missing the required parameter `voter` when calling `cosmos_gov_v1_vote`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proposal_id' in params:
            path_params['proposal_id'] = params['proposal_id']  # noqa: E501
        if 'voter' in params:
            path_params['voter'] = params['voter']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1/proposals/{proposal_id}/votes/{voter}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20046',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_gov_v1_votes(self, proposal_id, **kwargs):  # noqa: E501
        """Votes queries votes of a given proposal.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_votes(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20045
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_gov_v1_votes_with_http_info(proposal_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_gov_v1_votes_with_http_info(proposal_id, **kwargs)  # noqa: E501
            return data

    def cosmos_gov_v1_votes_with_http_info(self, proposal_id, **kwargs):  # noqa: E501
        """Votes queries votes of a given proposal.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_gov_v1_votes_with_http_info(proposal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proposal_id: proposal_id defines the unique id of the proposal. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20045
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proposal_id', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_gov_v1_votes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proposal_id' is set
        if ('proposal_id' not in params or
                params['proposal_id'] is None):
            raise ValueError("Missing the required parameter `proposal_id` when calling `cosmos_gov_v1_votes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proposal_id' in params:
            path_params['proposal_id'] = params['proposal_id']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/gov/v1/proposals/{proposal_id}/votes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20045',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_group_v1_group_info(self, group_id, **kwargs):  # noqa: E501
        """GroupInfo queries group info based on group id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_group_v1_group_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: group_id is the unique ID of the group. (required)
        :return: InlineResponse20054
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_group_v1_group_info_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_group_v1_group_info_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def cosmos_group_v1_group_info_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """GroupInfo queries group info based on group id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_group_v1_group_info_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: group_id is the unique ID of the group. (required)
        :return: InlineResponse20054
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_group_v1_group_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `cosmos_group_v1_group_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/group/v1/group_info/{group_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20054',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_group_v1_group_members(self, group_id, **kwargs):  # noqa: E501
        """GroupMembers queries members of a group by group id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_group_v1_group_members(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: group_id is the unique ID of the group. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20055
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_group_v1_group_members_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_group_v1_group_members_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def cosmos_group_v1_group_members_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """GroupMembers queries members of a group by group id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_group_v1_group_members_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: group_id is the unique ID of the group. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20055
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_group_v1_group_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `cosmos_group_v1_group_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/group/v1/group_members/{group_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20055',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_group_v1_groups(self, **kwargs):  # noqa: E501
        """Groups queries all groups in state.  # noqa: E501

        Since: cosmos-sdk 0.47.1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_group_v1_groups(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20056
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_group_v1_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_group_v1_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_group_v1_groups_with_http_info(self, **kwargs):  # noqa: E501
        """Groups queries all groups in state.  # noqa: E501

        Since: cosmos-sdk 0.47.1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_group_v1_groups_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20056
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_group_v1_groups" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/group/v1/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20056',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_group_v1_groups_by_admin(self, admin, **kwargs):  # noqa: E501
        """GroupsByAdmin queries groups by admin address.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_group_v1_groups_by_admin(admin, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str admin: admin is the account address of a group's admin. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20057
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_group_v1_groups_by_admin_with_http_info(admin, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_group_v1_groups_by_admin_with_http_info(admin, **kwargs)  # noqa: E501
            return data

    def cosmos_group_v1_groups_by_admin_with_http_info(self, admin, **kwargs):  # noqa: E501
        """GroupsByAdmin queries groups by admin address.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_group_v1_groups_by_admin_with_http_info(admin, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str admin: admin is the account address of a group's admin. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20057
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['admin', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_group_v1_groups_by_admin" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'admin' is set
        if ('admin' not in params or
                params['admin'] is None):
            raise ValueError("Missing the required parameter `admin` when calling `cosmos_group_v1_groups_by_admin`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'admin' in params:
            path_params['admin'] = params['admin']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/group/v1/groups_by_admin/{admin}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20057',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_group_v1_groups_by_member(self, address, **kwargs):  # noqa: E501
        """GroupsByMember queries groups by member address.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_group_v1_groups_by_member(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the group member address. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20058
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_group_v1_groups_by_member_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_group_v1_groups_by_member_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def cosmos_group_v1_groups_by_member_with_http_info(self, address, **kwargs):  # noqa: E501
        """GroupsByMember queries groups by member address.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_group_v1_groups_by_member_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the group member address. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20058
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_group_v1_groups_by_member" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `cosmos_group_v1_groups_by_member`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/group/v1/groups_by_member/{address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20058',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_mint_v1_beta1_annual_provisions(self, **kwargs):  # noqa: E501
        """AnnualProvisions current minting annual provisions value.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_mint_v1_beta1_annual_provisions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20059
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_mint_v1_beta1_annual_provisions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_mint_v1_beta1_annual_provisions_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_mint_v1_beta1_annual_provisions_with_http_info(self, **kwargs):  # noqa: E501
        """AnnualProvisions current minting annual provisions value.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_mint_v1_beta1_annual_provisions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20059
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_mint_v1_beta1_annual_provisions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/mint/v1beta1/annual_provisions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20059',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_mint_v1_beta1_inflation(self, **kwargs):  # noqa: E501
        """Inflation returns the current minting inflation value.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_mint_v1_beta1_inflation(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20060
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_mint_v1_beta1_inflation_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_mint_v1_beta1_inflation_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_mint_v1_beta1_inflation_with_http_info(self, **kwargs):  # noqa: E501
        """Inflation returns the current minting inflation value.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_mint_v1_beta1_inflation_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20060
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_mint_v1_beta1_inflation" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/mint/v1beta1/inflation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20060',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_mint_v1_beta1_params(self, **kwargs):  # noqa: E501
        """Params returns the total set of minting parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_mint_v1_beta1_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20061
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_mint_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_mint_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_mint_v1_beta1_params_with_http_info(self, **kwargs):  # noqa: E501
        """Params returns the total set of minting parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_mint_v1_beta1_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20061
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_mint_v1_beta1_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/mint/v1beta1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20061',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_nft_v1_beta1_balance(self, owner, class_id, **kwargs):  # noqa: E501
        """Balance queries the number of NFTs of a given class owned by the owner, same as balanceOf in ERC721  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_balance(owner, class_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: owner is the owner address of the nft (required)
        :param str class_id: class_id associated with the nft (required)
        :return: QueryBalanceResponseIsTheResponseTypeForTheQueryBalanceRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_nft_v1_beta1_balance_with_http_info(owner, class_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_nft_v1_beta1_balance_with_http_info(owner, class_id, **kwargs)  # noqa: E501
            return data

    def cosmos_nft_v1_beta1_balance_with_http_info(self, owner, class_id, **kwargs):  # noqa: E501
        """Balance queries the number of NFTs of a given class owned by the owner, same as balanceOf in ERC721  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_balance_with_http_info(owner, class_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: owner is the owner address of the nft (required)
        :param str class_id: class_id associated with the nft (required)
        :return: QueryBalanceResponseIsTheResponseTypeForTheQueryBalanceRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner', 'class_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_nft_v1_beta1_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner' is set
        if ('owner' not in params or
                params['owner'] is None):
            raise ValueError("Missing the required parameter `owner` when calling `cosmos_nft_v1_beta1_balance`")  # noqa: E501
        # verify the required parameter 'class_id' is set
        if ('class_id' not in params or
                params['class_id'] is None):
            raise ValueError("Missing the required parameter `class_id` when calling `cosmos_nft_v1_beta1_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in params:
            path_params['owner'] = params['owner']  # noqa: E501
        if 'class_id' in params:
            path_params['class_id'] = params['class_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/nft/v1beta1/balance/{owner}/{class_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryBalanceResponseIsTheResponseTypeForTheQueryBalanceRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_nft_v1_beta1_class(self, class_id, **kwargs):  # noqa: E501
        """Class queries an NFT class based on its id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_class(class_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str class_id: class_id associated with the nft (required)
        :return: QueryClassResponseIsTheResponseTypeForTheQueryClassRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_nft_v1_beta1_class_with_http_info(class_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_nft_v1_beta1_class_with_http_info(class_id, **kwargs)  # noqa: E501
            return data

    def cosmos_nft_v1_beta1_class_with_http_info(self, class_id, **kwargs):  # noqa: E501
        """Class queries an NFT class based on its id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_class_with_http_info(class_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str class_id: class_id associated with the nft (required)
        :return: QueryClassResponseIsTheResponseTypeForTheQueryClassRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['class_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_nft_v1_beta1_class" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'class_id' is set
        if ('class_id' not in params or
                params['class_id'] is None):
            raise ValueError("Missing the required parameter `class_id` when calling `cosmos_nft_v1_beta1_class`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'class_id' in params:
            path_params['class_id'] = params['class_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/nft/v1beta1/classes/{class_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryClassResponseIsTheResponseTypeForTheQueryClassRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_nft_v1_beta1_classes(self, **kwargs):  # noqa: E501
        """Classes queries all NFT classes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_classes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_nft_v1_beta1_classes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_nft_v1_beta1_classes_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_nft_v1_beta1_classes_with_http_info(self, **kwargs):  # noqa: E501
        """Classes queries all NFT classes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_classes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_nft_v1_beta1_classes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/nft/v1beta1/classes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_nft_v1_beta1_nft(self, class_id, id, **kwargs):  # noqa: E501
        """NFT queries an NFT based on its class and id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_nft(class_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str class_id: class_id associated with the nft (required)
        :param str id: id is a unique identifier of the NFT (required)
        :return: QueryNFTResponseIsTheResponseTypeForTheQueryNFTRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_nft_v1_beta1_nft_with_http_info(class_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_nft_v1_beta1_nft_with_http_info(class_id, id, **kwargs)  # noqa: E501
            return data

    def cosmos_nft_v1_beta1_nft_with_http_info(self, class_id, id, **kwargs):  # noqa: E501
        """NFT queries an NFT based on its class and id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_nft_with_http_info(class_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str class_id: class_id associated with the nft (required)
        :param str id: id is a unique identifier of the NFT (required)
        :return: QueryNFTResponseIsTheResponseTypeForTheQueryNFTRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['class_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_nft_v1_beta1_nft" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'class_id' is set
        if ('class_id' not in params or
                params['class_id'] is None):
            raise ValueError("Missing the required parameter `class_id` when calling `cosmos_nft_v1_beta1_nft`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `cosmos_nft_v1_beta1_nft`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'class_id' in params:
            path_params['class_id'] = params['class_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/nft/v1beta1/nfts/{class_id}/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryNFTResponseIsTheResponseTypeForTheQueryNFTRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_nft_v1_beta1_nfts(self, **kwargs):  # noqa: E501
        """NFTs queries all NFTs of a given class or owner,choose at least one of the two, similar to tokenByIndex in ERC721Enumerable  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_nfts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str class_id: class_id associated with the nft
        :param str owner: owner is the owner address of the nft
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethods
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_nft_v1_beta1_nfts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_nft_v1_beta1_nfts_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_nft_v1_beta1_nfts_with_http_info(self, **kwargs):  # noqa: E501
        """NFTs queries all NFTs of a given class or owner,choose at least one of the two, similar to tokenByIndex in ERC721Enumerable  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_nfts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str class_id: class_id associated with the nft
        :param str owner: owner is the owner address of the nft
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethods
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['class_id', 'owner', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_nft_v1_beta1_nfts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'class_id' in params:
            query_params.append(('class_id', params['class_id']))  # noqa: E501
        if 'owner' in params:
            query_params.append(('owner', params['owner']))  # noqa: E501
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/nft/v1beta1/nfts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethods',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_nft_v1_beta1_owner(self, class_id, id, **kwargs):  # noqa: E501
        """Owner queries the owner of the NFT based on its class and id, same as ownerOf in ERC721  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_owner(class_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str class_id: class_id associated with the nft (required)
        :param str id: id is a unique identifier of the NFT (required)
        :return: QueryOwnerResponseIsTheResponseTypeForTheQueryOwnerRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_nft_v1_beta1_owner_with_http_info(class_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_nft_v1_beta1_owner_with_http_info(class_id, id, **kwargs)  # noqa: E501
            return data

    def cosmos_nft_v1_beta1_owner_with_http_info(self, class_id, id, **kwargs):  # noqa: E501
        """Owner queries the owner of the NFT based on its class and id, same as ownerOf in ERC721  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_owner_with_http_info(class_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str class_id: class_id associated with the nft (required)
        :param str id: id is a unique identifier of the NFT (required)
        :return: QueryOwnerResponseIsTheResponseTypeForTheQueryOwnerRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['class_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_nft_v1_beta1_owner" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'class_id' is set
        if ('class_id' not in params or
                params['class_id'] is None):
            raise ValueError("Missing the required parameter `class_id` when calling `cosmos_nft_v1_beta1_owner`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `cosmos_nft_v1_beta1_owner`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'class_id' in params:
            path_params['class_id'] = params['class_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/nft/v1beta1/owner/{class_id}/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryOwnerResponseIsTheResponseTypeForTheQueryOwnerRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_nft_v1_beta1_supply(self, class_id, **kwargs):  # noqa: E501
        """Supply queries the number of NFTs from the given class, same as totalSupply of ERC721.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_supply(class_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str class_id: class_id associated with the nft (required)
        :return: QuerySupplyResponseIsTheResponseTypeForTheQuerySupplyRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_nft_v1_beta1_supply_with_http_info(class_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_nft_v1_beta1_supply_with_http_info(class_id, **kwargs)  # noqa: E501
            return data

    def cosmos_nft_v1_beta1_supply_with_http_info(self, class_id, **kwargs):  # noqa: E501
        """Supply queries the number of NFTs from the given class, same as totalSupply of ERC721.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_nft_v1_beta1_supply_with_http_info(class_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str class_id: class_id associated with the nft (required)
        :return: QuerySupplyResponseIsTheResponseTypeForTheQuerySupplyRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['class_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_nft_v1_beta1_supply" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'class_id' is set
        if ('class_id' not in params or
                params['class_id'] is None):
            raise ValueError("Missing the required parameter `class_id` when calling `cosmos_nft_v1_beta1_supply`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'class_id' in params:
            path_params['class_id'] = params['class_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/nft/v1beta1/supply/{class_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QuerySupplyResponseIsTheResponseTypeForTheQuerySupplyRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_params_v1_beta1_params(self, **kwargs):  # noqa: E501
        """Params queries a specific parameter of a module, given its subspace and key.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_params_v1_beta1_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str subspace: subspace defines the module to query the parameter for.
        :param str key: key defines the key of the parameter in the subspace.
        :return: InlineResponse20062
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_params_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_params_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_params_v1_beta1_params_with_http_info(self, **kwargs):  # noqa: E501
        """Params queries a specific parameter of a module, given its subspace and key.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_params_v1_beta1_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str subspace: subspace defines the module to query the parameter for.
        :param str key: key defines the key of the parameter in the subspace.
        :return: InlineResponse20062
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subspace', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_params_v1_beta1_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'subspace' in params:
            query_params.append(('subspace', params['subspace']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/params/v1beta1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20062',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_params_v1_beta1_subspaces(self, **kwargs):  # noqa: E501
        """Subspaces queries for all registered subspaces and all keys for a subspace.  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_params_v1_beta1_subspaces(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20063
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_params_v1_beta1_subspaces_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_params_v1_beta1_subspaces_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_params_v1_beta1_subspaces_with_http_info(self, **kwargs):  # noqa: E501
        """Subspaces queries for all registered subspaces and all keys for a subspace.  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_params_v1_beta1_subspaces_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20063
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_params_v1_beta1_subspaces" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/params/v1beta1/subspaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20063',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_slashing_v1_beta1_params(self, **kwargs):  # noqa: E501
        """Params queries the parameters of slashing module  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_slashing_v1_beta1_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_slashing_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_slashing_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_slashing_v1_beta1_params_with_http_info(self, **kwargs):  # noqa: E501
        """Params queries the parameters of slashing module  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_slashing_v1_beta1_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_slashing_v1_beta1_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/slashing/v1beta1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_slashing_v1_beta1_signing_info(self, cons_address, **kwargs):  # noqa: E501
        """SigningInfo queries the signing info of given cons address  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_slashing_v1_beta1_signing_info(cons_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cons_address: cons_address is the address to query signing info of (required)
        :return: QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCmethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_slashing_v1_beta1_signing_info_with_http_info(cons_address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_slashing_v1_beta1_signing_info_with_http_info(cons_address, **kwargs)  # noqa: E501
            return data

    def cosmos_slashing_v1_beta1_signing_info_with_http_info(self, cons_address, **kwargs):  # noqa: E501
        """SigningInfo queries the signing info of given cons address  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_slashing_v1_beta1_signing_info_with_http_info(cons_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cons_address: cons_address is the address to query signing info of (required)
        :return: QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCmethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cons_address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_slashing_v1_beta1_signing_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cons_address' is set
        if ('cons_address' not in params or
                params['cons_address'] is None):
            raise ValueError("Missing the required parameter `cons_address` when calling `cosmos_slashing_v1_beta1_signing_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cons_address' in params:
            path_params['cons_address'] = params['cons_address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/slashing/v1beta1/signing_infos/{cons_address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCmethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_slashing_v1_beta1_signing_infos(self, **kwargs):  # noqa: E501
        """SigningInfos queries signing info of all validators  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_slashing_v1_beta1_signing_infos(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCmethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_slashing_v1_beta1_signing_infos_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_slashing_v1_beta1_signing_infos_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_slashing_v1_beta1_signing_infos_with_http_info(self, **kwargs):  # noqa: E501
        """SigningInfos queries signing info of all validators  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_slashing_v1_beta1_signing_infos_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCmethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_slashing_v1_beta1_signing_infos" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/slashing/v1beta1/signing_infos', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCmethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_delegation(self, delegator_addr, **kwargs):  # noqa: E501
        """Delegation queries delegate info for given validator delegator pair.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_delegation(delegator_addr, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delegator_addr: delegator_addr defines the delegator address to query for. (required)
        :return: InlineResponse20064
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_delegation_with_http_info(delegator_addr, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_delegation_with_http_info(delegator_addr, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_delegation_with_http_info(self, delegator_addr, **kwargs):  # noqa: E501
        """Delegation queries delegate info for given validator delegator pair.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_delegation_with_http_info(delegator_addr, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delegator_addr: delegator_addr defines the delegator address to query for. (required)
        :return: InlineResponse20064
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delegator_addr']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_delegation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delegator_addr' is set
        if ('delegator_addr' not in params or
                params['delegator_addr'] is None):
            raise ValueError("Missing the required parameter `delegator_addr` when calling `cosmos_staking_v1_beta1_delegation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'delegator_addr' in params:
            path_params['delegator_addr'] = params['delegator_addr']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/delegation/{delegator_addr}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20064',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_fixed_deposit(self, id, **kwargs):  # noqa: E501
        """Queries a list of FixedDeposit items.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_fixed_deposit(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str address:
        :return: InlineResponse20066
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_fixed_deposit_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_fixed_deposit_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_fixed_deposit_with_http_info(self, id, **kwargs):  # noqa: E501
        """Queries a list of FixedDeposit items.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_fixed_deposit_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str address:
        :return: InlineResponse20066
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_fixed_deposit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `cosmos_staking_v1_beta1_fixed_deposit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'address' in params:
            query_params.append(('address', params['address']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/fixed_deposit/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20066',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_fixed_deposit_all(self, **kwargs):  # noqa: E501
        """cosmos_staking_v1_beta1_fixed_deposit_all  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_fixed_deposit_all(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20065
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_fixed_deposit_all_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_fixed_deposit_all_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_fixed_deposit_all_with_http_info(self, **kwargs):  # noqa: E501
        """cosmos_staking_v1_beta1_fixed_deposit_all  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_fixed_deposit_all_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20065
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_fixed_deposit_all" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/fixed_deposit', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20065',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_fixed_deposit_by_acct(self, account, query_type, **kwargs):  # noqa: E501
        """Queries a list of FixedDepositByAcct items.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_fixed_deposit_by_acct(account, query_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account: cosmos.base.query.v1beta1.PageRequest pagination = 1; (required)
        :param str query_type: (required)
        :return: InlineResponse20067
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_fixed_deposit_by_acct_with_http_info(account, query_type, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_fixed_deposit_by_acct_with_http_info(account, query_type, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_fixed_deposit_by_acct_with_http_info(self, account, query_type, **kwargs):  # noqa: E501
        """Queries a list of FixedDepositByAcct items.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_fixed_deposit_by_acct_with_http_info(account, query_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account: cosmos.base.query.v1beta1.PageRequest pagination = 1; (required)
        :param str query_type: (required)
        :return: InlineResponse20067
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account', 'query_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_fixed_deposit_by_acct" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account' is set
        if ('account' not in params or
                params['account'] is None):
            raise ValueError("Missing the required parameter `account` when calling `cosmos_staking_v1_beta1_fixed_deposit_by_acct`")  # noqa: E501
        # verify the required parameter 'query_type' is set
        if ('query_type' not in params or
                params['query_type'] is None):
            raise ValueError("Missing the required parameter `query_type` when calling `cosmos_staking_v1_beta1_fixed_deposit_by_acct`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account' in params:
            path_params['account'] = params['account']  # noqa: E501
        if 'query_type' in params:
            path_params['query_type'] = params['query_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/fixed_deposit_by_acct/{account}/{query_type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20067',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_fixed_deposit_by_region(self, regionid, **kwargs):  # noqa: E501
        """Queries a list of FixedDepositByRegion items.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_fixed_deposit_by_region(regionid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str regionid: (required)
        :param str query_type: cosmos.base.query.v1beta1.PageRequest pagination = 2;
        :return: InlineResponse20067
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_fixed_deposit_by_region_with_http_info(regionid, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_fixed_deposit_by_region_with_http_info(regionid, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_fixed_deposit_by_region_with_http_info(self, regionid, **kwargs):  # noqa: E501
        """Queries a list of FixedDepositByRegion items.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_fixed_deposit_by_region_with_http_info(regionid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str regionid: (required)
        :param str query_type: cosmos.base.query.v1beta1.PageRequest pagination = 2;
        :return: InlineResponse20067
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['regionid', 'query_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_fixed_deposit_by_region" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'regionid' is set
        if ('regionid' not in params or
                params['regionid'] is None):
            raise ValueError("Missing the required parameter `regionid` when calling `cosmos_staking_v1_beta1_fixed_deposit_by_region`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'regionid' in params:
            path_params['regionid'] = params['regionid']  # noqa: E501

        query_params = []
        if 'query_type' in params:
            query_params.append(('query_type', params['query_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/fixed_deposit_by_region/{regionid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20067',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_fixed_deposit_interest_rate(self, **kwargs):  # noqa: E501
        """Queries FixedDepositInterest Item.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_fixed_deposit_interest_rate(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20068
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_fixed_deposit_interest_rate_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_fixed_deposit_interest_rate_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_fixed_deposit_interest_rate_with_http_info(self, **kwargs):  # noqa: E501
        """Queries FixedDepositInterest Item.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_fixed_deposit_interest_rate_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20068
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_fixed_deposit_interest_rate" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/fixed_deposit_interest_rate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20068',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_historical_info(self, height, **kwargs):  # noqa: E501
        """HistoricalInfo queries the historical info for given height.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_historical_info(height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str height: height defines at which height to query the historical info. (required)
        :return: InlineResponse20069
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_historical_info_with_http_info(height, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_historical_info_with_http_info(height, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_historical_info_with_http_info(self, height, **kwargs):  # noqa: E501
        """HistoricalInfo queries the historical info for given height.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_historical_info_with_http_info(height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str height: height defines at which height to query the historical info. (required)
        :return: InlineResponse20069
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['height']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_historical_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'height' is set
        if ('height' not in params or
                params['height'] is None):
            raise ValueError("Missing the required parameter `height` when calling `cosmos_staking_v1_beta1_historical_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'height' in params:
            path_params['height'] = params['height']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/historical_info/{height}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20069',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_kyc(self, account, **kwargs):  # noqa: E501
        """Queries a list of Kyc items.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_kyc(account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account: (required)
        :return: InlineResponse20071
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_kyc_with_http_info(account, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_kyc_with_http_info(account, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_kyc_with_http_info(self, account, **kwargs):  # noqa: E501
        """Queries a list of Kyc items.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_kyc_with_http_info(account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account: (required)
        :return: InlineResponse20071
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_kyc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account' is set
        if ('account' not in params or
                params['account'] is None):
            raise ValueError("Missing the required parameter `account` when calling `cosmos_staking_v1_beta1_kyc`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account' in params:
            path_params['account'] = params['account']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/kyc/{account}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20071',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_kyc_all(self, **kwargs):  # noqa: E501
        """cosmos_staking_v1_beta1_kyc_all  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_kyc_all(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20070
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_kyc_all_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_kyc_all_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_kyc_all_with_http_info(self, **kwargs):  # noqa: E501
        """cosmos_staking_v1_beta1_kyc_all  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_kyc_all_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20070
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_kyc_all" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/kyc', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20070',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_kyc_by_region(self, region_id, **kwargs):  # noqa: E501
        """Queries a list of KycByRegion items.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_kyc_by_region(region_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str region_id: (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20070
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_kyc_by_region_with_http_info(region_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_kyc_by_region_with_http_info(region_id, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_kyc_by_region_with_http_info(self, region_id, **kwargs):  # noqa: E501
        """Queries a list of KycByRegion items.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_kyc_by_region_with_http_info(region_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str region_id: (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20070
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['region_id', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_kyc_by_region" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'region_id' is set
        if ('region_id' not in params or
                params['region_id'] is None):
            raise ValueError("Missing the required parameter `region_id` when calling `cosmos_staking_v1_beta1_kyc_by_region`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'region_id' in params:
            path_params['regionId'] = params['region_id']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/kyc_by_region/{regionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20070',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_params(self, **kwargs):  # noqa: E501
        """Parameters queries the staking parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20072
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_params_with_http_info(self, **kwargs):  # noqa: E501
        """Parameters queries the staking parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20072
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20072',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_pool(self, **kwargs):  # noqa: E501
        """Pool queries the pool info.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_pool(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20073
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_pool_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_pool_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_pool_with_http_info(self, **kwargs):  # noqa: E501
        """Pool queries the pool info.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_pool_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20073
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_pool" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/pool', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20073',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_region(self, region_id, **kwargs):  # noqa: E501
        """Queries a list of Region items.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_region(region_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str region_id: (required)
        :return: InlineResponse20075
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_region_with_http_info(region_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_region_with_http_info(region_id, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_region_with_http_info(self, region_id, **kwargs):  # noqa: E501
        """Queries a list of Region items.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_region_with_http_info(region_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str region_id: (required)
        :return: InlineResponse20075
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['region_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_region" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'region_id' is set
        if ('region_id' not in params or
                params['region_id'] is None):
            raise ValueError("Missing the required parameter `region_id` when calling `cosmos_staking_v1_beta1_region`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'region_id' in params:
            path_params['regionId'] = params['region_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/region/{regionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20075',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_region_all(self, **kwargs):  # noqa: E501
        """cosmos_staking_v1_beta1_region_all  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_region_all(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20074
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_region_all_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_region_all_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_region_all_with_http_info(self, **kwargs):  # noqa: E501
        """cosmos_staking_v1_beta1_region_all  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_region_all_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20074
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_region_all" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/region', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20074',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_siid(self, siid, **kwargs):  # noqa: E501
        """cosmos_staking_v1_beta1_siid  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_siid(siid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str siid: (required)
        :return: InlineResponse20077
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_siid_with_http_info(siid, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_siid_with_http_info(siid, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_siid_with_http_info(self, siid, **kwargs):  # noqa: E501
        """cosmos_staking_v1_beta1_siid  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_siid_with_http_info(siid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str siid: (required)
        :return: InlineResponse20077
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['siid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_siid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'siid' is set
        if ('siid' not in params or
                params['siid'] is None):
            raise ValueError("Missing the required parameter `siid` when calling `cosmos_staking_v1_beta1_siid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'siid' in params:
            path_params['siid'] = params['siid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/siid/{siid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20077',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_siid_all(self, **kwargs):  # noqa: E501
        """cosmos_staking_v1_beta1_siid_all  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_siid_all(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20076
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_siid_all_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_siid_all_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_siid_all_with_http_info(self, **kwargs):  # noqa: E501
        """cosmos_staking_v1_beta1_siid_all  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_siid_all_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20076
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_siid_all" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/siid', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20076',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_siid_by_account(self, account, **kwargs):  # noqa: E501
        """cosmos_staking_v1_beta1_siid_by_account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_siid_by_account(account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account: (required)
        :return: InlineResponse20077
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_siid_by_account_with_http_info(account, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_siid_by_account_with_http_info(account, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_siid_by_account_with_http_info(self, account, **kwargs):  # noqa: E501
        """cosmos_staking_v1_beta1_siid_by_account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_siid_by_account_with_http_info(account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account: (required)
        :return: InlineResponse20077
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_siid_by_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account' is set
        if ('account' not in params or
                params['account'] is None):
            raise ValueError("Missing the required parameter `account` when calling `cosmos_staking_v1_beta1_siid_by_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account' in params:
            path_params['account'] = params['account']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/siid_by_account/{account}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20077',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_unbonding_delegation(self, delegator_addr, **kwargs):  # noqa: E501
        """UnbondingDelegation queries unbonding info for given validator delegator pair.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_unbonding_delegation(delegator_addr, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delegator_addr: delegator_addr defines the delegator address to query for. (required)
        :return: InlineResponse20078
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_unbonding_delegation_with_http_info(delegator_addr, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_unbonding_delegation_with_http_info(delegator_addr, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_unbonding_delegation_with_http_info(self, delegator_addr, **kwargs):  # noqa: E501
        """UnbondingDelegation queries unbonding info for given validator delegator pair.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_unbonding_delegation_with_http_info(delegator_addr, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delegator_addr: delegator_addr defines the delegator address to query for. (required)
        :return: InlineResponse20078
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delegator_addr']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_unbonding_delegation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delegator_addr' is set
        if ('delegator_addr' not in params or
                params['delegator_addr'] is None):
            raise ValueError("Missing the required parameter `delegator_addr` when calling `cosmos_staking_v1_beta1_unbonding_delegation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'delegator_addr' in params:
            path_params['delegator_addr'] = params['delegator_addr']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/unbonding_delegation/{delegator_addr}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20078',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_validator(self, validator_addr, **kwargs):  # noqa: E501
        """Validator queries validator info for given validator address.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_validator(validator_addr, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str validator_addr: validator_addr defines the validator address to query for. (required)
        :return: QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_validator_with_http_info(validator_addr, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_validator_with_http_info(validator_addr, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_validator_with_http_info(self, validator_addr, **kwargs):  # noqa: E501
        """Validator queries validator info for given validator address.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_validator_with_http_info(validator_addr, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str validator_addr: validator_addr defines the validator address to query for. (required)
        :return: QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['validator_addr']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_validator" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'validator_addr' is set
        if ('validator_addr' not in params or
                params['validator_addr'] is None):
            raise ValueError("Missing the required parameter `validator_addr` when calling `cosmos_staking_v1_beta1_validator`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'validator_addr' in params:
            path_params['validator_addr'] = params['validator_addr']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/validators/{validator_addr}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_validator_delegations(self, validator_addr, **kwargs):  # noqa: E501
        """ValidatorDelegations queries delegate info for given validator.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_validator_delegations(validator_addr, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str validator_addr: validator_addr defines the validator address to query for. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_validator_delegations_with_http_info(validator_addr, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_validator_delegations_with_http_info(validator_addr, **kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_validator_delegations_with_http_info(self, validator_addr, **kwargs):  # noqa: E501
        """ValidatorDelegations queries delegate info for given validator.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_validator_delegations_with_http_info(validator_addr, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str validator_addr: validator_addr defines the validator address to query for. (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['validator_addr', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_validator_delegations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'validator_addr' is set
        if ('validator_addr' not in params or
                params['validator_addr'] is None):
            raise ValueError("Missing the required parameter `validator_addr` when calling `cosmos_staking_v1_beta1_validator_delegations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'validator_addr' in params:
            path_params['validator_addr'] = params['validator_addr']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/validators/{validator_addr}/delegations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_staking_v1_beta1_validators(self, **kwargs):  # noqa: E501
        """Validators queries all validators that match the given status.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_validators(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str status: status enables to query for validators matching a given status.
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_staking_v1_beta1_validators_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_staking_v1_beta1_validators_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_staking_v1_beta1_validators_with_http_info(self, **kwargs):  # noqa: E501
        """Validators queries all validators that match the given status.  # noqa: E501

        When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_staking_v1_beta1_validators_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str status: status enables to query for validators matching a given status.
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['status', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_staking_v1_beta1_validators" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/staking/v1beta1/validators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_upgrade_v1_beta1_applied_plan(self, name, **kwargs):  # noqa: E501
        """AppliedPlan queries a previously applied upgrade plan by its name.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_upgrade_v1_beta1_applied_plan(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name is the name of the applied plan to query for. (required)
        :return: InlineResponse20084
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_upgrade_v1_beta1_applied_plan_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_upgrade_v1_beta1_applied_plan_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def cosmos_upgrade_v1_beta1_applied_plan_with_http_info(self, name, **kwargs):  # noqa: E501
        """AppliedPlan queries a previously applied upgrade plan by its name.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_upgrade_v1_beta1_applied_plan_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name is the name of the applied plan to query for. (required)
        :return: InlineResponse20084
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_upgrade_v1_beta1_applied_plan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `cosmos_upgrade_v1_beta1_applied_plan`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/upgrade/v1beta1/applied_plan/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20084',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_upgrade_v1_beta1_authority(self, **kwargs):  # noqa: E501
        """Returns the account with authority to conduct upgrades  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_upgrade_v1_beta1_authority(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: QueryAuthorityResponseIsTheResponseTypeForQueryAuthority
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_upgrade_v1_beta1_authority_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_upgrade_v1_beta1_authority_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_upgrade_v1_beta1_authority_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the account with authority to conduct upgrades  # noqa: E501

        Since: cosmos-sdk 0.46  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_upgrade_v1_beta1_authority_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: QueryAuthorityResponseIsTheResponseTypeForQueryAuthority
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_upgrade_v1_beta1_authority" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/upgrade/v1beta1/authority', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryAuthorityResponseIsTheResponseTypeForQueryAuthority',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_upgrade_v1_beta1_current_plan(self, **kwargs):  # noqa: E501
        """CurrentPlan queries the current upgrade plan.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_upgrade_v1_beta1_current_plan(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20085
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_upgrade_v1_beta1_current_plan_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_upgrade_v1_beta1_current_plan_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_upgrade_v1_beta1_current_plan_with_http_info(self, **kwargs):  # noqa: E501
        """CurrentPlan queries the current upgrade plan.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_upgrade_v1_beta1_current_plan_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20085
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_upgrade_v1_beta1_current_plan" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/upgrade/v1beta1/current_plan', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20085',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_upgrade_v1_beta1_module_versions(self, **kwargs):  # noqa: E501
        """ModuleVersions queries the list of module versions from state.  # noqa: E501

        Since: cosmos-sdk 0.43  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_upgrade_v1_beta1_module_versions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str module_name: module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state
        :return: InlineResponse20086
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_upgrade_v1_beta1_module_versions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_upgrade_v1_beta1_module_versions_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmos_upgrade_v1_beta1_module_versions_with_http_info(self, **kwargs):  # noqa: E501
        """ModuleVersions queries the list of module versions from state.  # noqa: E501

        Since: cosmos-sdk 0.43  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_upgrade_v1_beta1_module_versions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str module_name: module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state
        :return: InlineResponse20086
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['module_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_upgrade_v1_beta1_module_versions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'module_name' in params:
            query_params.append(('module_name', params['module_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/upgrade/v1beta1/module_versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20086',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmos_upgrade_v1_beta1_upgraded_consensus_state(self, last_height, **kwargs):  # noqa: E501
        """UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier This rpc is deprecated now that IBC has its own replacement (https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_upgrade_v1_beta1_upgraded_consensus_state(last_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str last_height: last height of the current chain must be sent in request as this is the height under which next consensus state is stored (required)
        :return: InlineResponse20087
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmos_upgrade_v1_beta1_upgraded_consensus_state_with_http_info(last_height, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmos_upgrade_v1_beta1_upgraded_consensus_state_with_http_info(last_height, **kwargs)  # noqa: E501
            return data

    def cosmos_upgrade_v1_beta1_upgraded_consensus_state_with_http_info(self, last_height, **kwargs):  # noqa: E501
        """UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier This rpc is deprecated now that IBC has its own replacement (https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmos_upgrade_v1_beta1_upgraded_consensus_state_with_http_info(last_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str last_height: last height of the current chain must be sent in request as this is the height under which next consensus state is stored (required)
        :return: InlineResponse20087
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['last_height']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmos_upgrade_v1_beta1_upgraded_consensus_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'last_height' is set
        if ('last_height' not in params or
                params['last_height'] is None):
            raise ValueError("Missing the required parameter `last_height` when calling `cosmos_upgrade_v1_beta1_upgraded_consensus_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'last_height' in params:
            path_params['last_height'] = params['last_height']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20087',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmwasm_wasm_v1_all_contract_state(self, address, **kwargs):  # noqa: E501
        """AllContractState gets all raw store data for a single contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_all_contract_state(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address of the contract (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryAllContractStateResponseIsTheResponseTypeForTheQueryAllContractStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmwasm_wasm_v1_all_contract_state_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmwasm_wasm_v1_all_contract_state_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def cosmwasm_wasm_v1_all_contract_state_with_http_info(self, address, **kwargs):  # noqa: E501
        """AllContractState gets all raw store data for a single contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_all_contract_state_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address of the contract (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryAllContractStateResponseIsTheResponseTypeForTheQueryAllContractStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmwasm_wasm_v1_all_contract_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `cosmwasm_wasm_v1_all_contract_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmwasm/wasm/v1/contract/{address}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryAllContractStateResponseIsTheResponseTypeForTheQueryAllContractStateRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmwasm_wasm_v1_code(self, code_id, **kwargs):  # noqa: E501
        """Code gets the binary code and metadata for a singe wasm code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_code(code_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str code_id: grpc-gateway_out does not support Go style CodID (required)
        :return: QueryCodeResponseIsTheResponseTypeForTheQueryCodeRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmwasm_wasm_v1_code_with_http_info(code_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmwasm_wasm_v1_code_with_http_info(code_id, **kwargs)  # noqa: E501
            return data

    def cosmwasm_wasm_v1_code_with_http_info(self, code_id, **kwargs):  # noqa: E501
        """Code gets the binary code and metadata for a singe wasm code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_code_with_http_info(code_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str code_id: grpc-gateway_out does not support Go style CodID (required)
        :return: QueryCodeResponseIsTheResponseTypeForTheQueryCodeRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['code_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmwasm_wasm_v1_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'code_id' is set
        if ('code_id' not in params or
                params['code_id'] is None):
            raise ValueError("Missing the required parameter `code_id` when calling `cosmwasm_wasm_v1_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'code_id' in params:
            path_params['code_id'] = params['code_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmwasm/wasm/v1/code/{code_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryCodeResponseIsTheResponseTypeForTheQueryCodeRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmwasm_wasm_v1_codes(self, **kwargs):  # noqa: E501
        """Codes gets the metadata for all stored wasm codes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_codes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryCodesResponseIsTheResponseTypeForTheQueryCodesRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmwasm_wasm_v1_codes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmwasm_wasm_v1_codes_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmwasm_wasm_v1_codes_with_http_info(self, **kwargs):  # noqa: E501
        """Codes gets the metadata for all stored wasm codes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_codes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryCodesResponseIsTheResponseTypeForTheQueryCodesRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmwasm_wasm_v1_codes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmwasm/wasm/v1/code', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryCodesResponseIsTheResponseTypeForTheQueryCodesRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmwasm_wasm_v1_contract_history(self, address, **kwargs):  # noqa: E501
        """ContractHistory gets the contract code history  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_contract_history(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address of the contract to query (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryContractHistoryResponseIsTheResponseTypeForTheQueryContractHistoryRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmwasm_wasm_v1_contract_history_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmwasm_wasm_v1_contract_history_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def cosmwasm_wasm_v1_contract_history_with_http_info(self, address, **kwargs):  # noqa: E501
        """ContractHistory gets the contract code history  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_contract_history_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address of the contract to query (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryContractHistoryResponseIsTheResponseTypeForTheQueryContractHistoryRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmwasm_wasm_v1_contract_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `cosmwasm_wasm_v1_contract_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmwasm/wasm/v1/contract/{address}/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryContractHistoryResponseIsTheResponseTypeForTheQueryContractHistoryRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmwasm_wasm_v1_contract_info(self, address, **kwargs):  # noqa: E501
        """ContractInfo gets the contract meta data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_contract_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address of the contract to query (required)
        :return: QueryContractInfoResponseIsTheResponseTypeForTheQueryContractInfoRPCmethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmwasm_wasm_v1_contract_info_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmwasm_wasm_v1_contract_info_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def cosmwasm_wasm_v1_contract_info_with_http_info(self, address, **kwargs):  # noqa: E501
        """ContractInfo gets the contract meta data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_contract_info_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address of the contract to query (required)
        :return: QueryContractInfoResponseIsTheResponseTypeForTheQueryContractInfoRPCmethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmwasm_wasm_v1_contract_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `cosmwasm_wasm_v1_contract_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmwasm/wasm/v1/contract/{address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryContractInfoResponseIsTheResponseTypeForTheQueryContractInfoRPCmethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmwasm_wasm_v1_contracts_by_code(self, code_id, **kwargs):  # noqa: E501
        """ContractsByCode lists all smart contracts for a code id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_contracts_by_code(code_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str code_id: grpc-gateway_out does not support Go style CodID (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryContractsByCodeResponseIsTheResponseTypeForTheQueryContractsByCodeRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmwasm_wasm_v1_contracts_by_code_with_http_info(code_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmwasm_wasm_v1_contracts_by_code_with_http_info(code_id, **kwargs)  # noqa: E501
            return data

    def cosmwasm_wasm_v1_contracts_by_code_with_http_info(self, code_id, **kwargs):  # noqa: E501
        """ContractsByCode lists all smart contracts for a code id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_contracts_by_code_with_http_info(code_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str code_id: grpc-gateway_out does not support Go style CodID (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryContractsByCodeResponseIsTheResponseTypeForTheQueryContractsByCodeRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['code_id', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmwasm_wasm_v1_contracts_by_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'code_id' is set
        if ('code_id' not in params or
                params['code_id'] is None):
            raise ValueError("Missing the required parameter `code_id` when calling `cosmwasm_wasm_v1_contracts_by_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'code_id' in params:
            path_params['code_id'] = params['code_id']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmwasm/wasm/v1/code/{code_id}/contracts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryContractsByCodeResponseIsTheResponseTypeForTheQueryContractsByCodeRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmwasm_wasm_v1_contracts_by_creator(self, creator_address, **kwargs):  # noqa: E501
        """ContractsByCreator gets the contracts by creator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_contracts_by_creator(creator_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str creator_address: CreatorAddress is the address of contract creator (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20089
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmwasm_wasm_v1_contracts_by_creator_with_http_info(creator_address, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmwasm_wasm_v1_contracts_by_creator_with_http_info(creator_address, **kwargs)  # noqa: E501
            return data

    def cosmwasm_wasm_v1_contracts_by_creator_with_http_info(self, creator_address, **kwargs):  # noqa: E501
        """ContractsByCreator gets the contracts by creator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_contracts_by_creator_with_http_info(creator_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str creator_address: CreatorAddress is the address of contract creator (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20089
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['creator_address', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmwasm_wasm_v1_contracts_by_creator" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'creator_address' is set
        if ('creator_address' not in params or
                params['creator_address'] is None):
            raise ValueError("Missing the required parameter `creator_address` when calling `cosmwasm_wasm_v1_contracts_by_creator`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'creator_address' in params:
            path_params['creator_address'] = params['creator_address']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmwasm/wasm/v1/contracts/creator/{creator_address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20089',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmwasm_wasm_v1_params(self, **kwargs):  # noqa: E501
        """Params gets the module params  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20088
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmwasm_wasm_v1_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmwasm_wasm_v1_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmwasm_wasm_v1_params_with_http_info(self, **kwargs):  # noqa: E501
        """Params gets the module params  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20088
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmwasm_wasm_v1_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmwasm/wasm/v1/codes/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20088',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmwasm_wasm_v1_pinned_codes(self, **kwargs):  # noqa: E501
        """PinnedCodes gets the pinned code ids  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_pinned_codes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryPinnedCodesResponseIsTheResponseTypeForTheQueryPinnedCodesRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmwasm_wasm_v1_pinned_codes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cosmwasm_wasm_v1_pinned_codes_with_http_info(**kwargs)  # noqa: E501
            return data

    def cosmwasm_wasm_v1_pinned_codes_with_http_info(self, **kwargs):  # noqa: E501
        """PinnedCodes gets the pinned code ids  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_pinned_codes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryPinnedCodesResponseIsTheResponseTypeForTheQueryPinnedCodesRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmwasm_wasm_v1_pinned_codes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmwasm/wasm/v1/codes/pinned', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPinnedCodesResponseIsTheResponseTypeForTheQueryPinnedCodesRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmwasm_wasm_v1_raw_contract_state(self, address, query_data, **kwargs):  # noqa: E501
        """RawContractState gets single key from the raw store data of a contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_raw_contract_state(address, query_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address of the contract (required)
        :param str query_data: (required)
        :return: QueryRawContractStateResponseIsTheResponseTypeForTheQueryRawContractStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmwasm_wasm_v1_raw_contract_state_with_http_info(address, query_data, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmwasm_wasm_v1_raw_contract_state_with_http_info(address, query_data, **kwargs)  # noqa: E501
            return data

    def cosmwasm_wasm_v1_raw_contract_state_with_http_info(self, address, query_data, **kwargs):  # noqa: E501
        """RawContractState gets single key from the raw store data of a contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_raw_contract_state_with_http_info(address, query_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address of the contract (required)
        :param str query_data: (required)
        :return: QueryRawContractStateResponseIsTheResponseTypeForTheQueryRawContractStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'query_data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmwasm_wasm_v1_raw_contract_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `cosmwasm_wasm_v1_raw_contract_state`")  # noqa: E501
        # verify the required parameter 'query_data' is set
        if ('query_data' not in params or
                params['query_data'] is None):
            raise ValueError("Missing the required parameter `query_data` when calling `cosmwasm_wasm_v1_raw_contract_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'query_data' in params:
            path_params['query_data'] = params['query_data']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmwasm/wasm/v1/contract/{address}/raw/{query_data}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryRawContractStateResponseIsTheResponseTypeForTheQueryRawContractStateRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cosmwasm_wasm_v1_smart_contract_state(self, address, query_data, **kwargs):  # noqa: E501
        """SmartContractState get smart query result from the contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_smart_contract_state(address, query_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address of the contract (required)
        :param str query_data: QueryData contains the query data passed to the contract (required)
        :return: QuerySmartContractStateResponseIsTheResponseTypeForTheQuerySmartContractStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cosmwasm_wasm_v1_smart_contract_state_with_http_info(address, query_data, **kwargs)  # noqa: E501
        else:
            (data) = self.cosmwasm_wasm_v1_smart_contract_state_with_http_info(address, query_data, **kwargs)  # noqa: E501
            return data

    def cosmwasm_wasm_v1_smart_contract_state_with_http_info(self, address, query_data, **kwargs):  # noqa: E501
        """SmartContractState get smart query result from the contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cosmwasm_wasm_v1_smart_contract_state_with_http_info(address, query_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: address is the address of the contract (required)
        :param str query_data: QueryData contains the query data passed to the contract (required)
        :return: QuerySmartContractStateResponseIsTheResponseTypeForTheQuerySmartContractStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'query_data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cosmwasm_wasm_v1_smart_contract_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `cosmwasm_wasm_v1_smart_contract_state`")  # noqa: E501
        # verify the required parameter 'query_data' is set
        if ('query_data' not in params or
                params['query_data'] is None):
            raise ValueError("Missing the required parameter `query_data` when calling `cosmwasm_wasm_v1_smart_contract_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'query_data' in params:
            path_params['query_data'] = params['query_data']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cosmwasm/wasm/v1/contract/{address}/smart/{query_data}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QuerySmartContractStateResponseIsTheResponseTypeForTheQuerySmartContractStateRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_fee_v1_counterparty_payee(self, channel_id, relayer, **kwargs):  # noqa: E501
        """CounterpartyPayee returns the registered counterparty payee for forward relaying  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_counterparty_payee(channel_id, relayer, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: unique channel identifier (required)
        :param str relayer: the relayer address to which the counterparty is registered (required)
        :return: QueryCounterpartyPayeeResponseDefinesTheResponseTypeForTheCounterpartyPayeeRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_fee_v1_counterparty_payee_with_http_info(channel_id, relayer, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_fee_v1_counterparty_payee_with_http_info(channel_id, relayer, **kwargs)  # noqa: E501
            return data

    def ibc_applications_fee_v1_counterparty_payee_with_http_info(self, channel_id, relayer, **kwargs):  # noqa: E501
        """CounterpartyPayee returns the registered counterparty payee for forward relaying  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_counterparty_payee_with_http_info(channel_id, relayer, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: unique channel identifier (required)
        :param str relayer: the relayer address to which the counterparty is registered (required)
        :return: QueryCounterpartyPayeeResponseDefinesTheResponseTypeForTheCounterpartyPayeeRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'relayer']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_fee_v1_counterparty_payee" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_applications_fee_v1_counterparty_payee`")  # noqa: E501
        # verify the required parameter 'relayer' is set
        if ('relayer' not in params or
                params['relayer'] is None):
            raise ValueError("Missing the required parameter `relayer` when calling `ibc_applications_fee_v1_counterparty_payee`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'relayer' in params:
            path_params['relayer'] = params['relayer']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/fee/v1/channels/{channel_id}/relayers/{relayer}/counterparty_payee', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryCounterpartyPayeeResponseDefinesTheResponseTypeForTheCounterpartyPayeeRpc',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_fee_v1_fee_enabled_channel(self, channel_id, port_id, **kwargs):  # noqa: E501
        """FeeEnabledChannel returns true if the provided port and channel identifiers belong to a fee enabled channel  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_fee_enabled_channel(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: unique channel identifier (required)
        :param str port_id: unique port identifier (required)
        :return: QueryFeeEnabledChannelResponseDefinesTheResponseTypeForTheFeeEnabledChannelRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_fee_v1_fee_enabled_channel_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_fee_v1_fee_enabled_channel_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
            return data

    def ibc_applications_fee_v1_fee_enabled_channel_with_http_info(self, channel_id, port_id, **kwargs):  # noqa: E501
        """FeeEnabledChannel returns true if the provided port and channel identifiers belong to a fee enabled channel  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_fee_enabled_channel_with_http_info(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: unique channel identifier (required)
        :param str port_id: unique port identifier (required)
        :return: QueryFeeEnabledChannelResponseDefinesTheResponseTypeForTheFeeEnabledChannelRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_fee_v1_fee_enabled_channel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_applications_fee_v1_fee_enabled_channel`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_applications_fee_v1_fee_enabled_channel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/fee/v1/channels/{channel_id}/ports/{port_id}/fee_enabled', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryFeeEnabledChannelResponseDefinesTheResponseTypeForTheFeeEnabledChannelRpc',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_fee_v1_fee_enabled_channels(self, **kwargs):  # noqa: E501
        """FeeEnabledChannels returns a list of all fee enabled channels  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_fee_enabled_channels(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :param str query_height: block height at which to query
        :return: QueryFeeEnabledChannelsResponseDefinesTheResponseTypeForTheFeeEnabledChannelsRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_fee_v1_fee_enabled_channels_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_fee_v1_fee_enabled_channels_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_applications_fee_v1_fee_enabled_channels_with_http_info(self, **kwargs):  # noqa: E501
        """FeeEnabledChannels returns a list of all fee enabled channels  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_fee_enabled_channels_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :param str query_height: block height at which to query
        :return: QueryFeeEnabledChannelsResponseDefinesTheResponseTypeForTheFeeEnabledChannelsRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse', 'query_height']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_fee_v1_fee_enabled_channels" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501
        if 'query_height' in params:
            query_params.append(('query_height', params['query_height']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/fee/v1/fee_enabled', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryFeeEnabledChannelsResponseDefinesTheResponseTypeForTheFeeEnabledChannelsRpc',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_fee_v1_incentivized_packet(self, packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs):  # noqa: E501
        """IncentivizedPacket returns all packet fees for a packet given its identifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_incentivized_packet(packet_id_channel_id, packet_id_port_id, packet_id_sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str packet_id_channel_id: channel unique identifier (required)
        :param str packet_id_port_id: channel port identifier (required)
        :param str packet_id_sequence: packet sequence (required)
        :param str query_height: block height at which to query
        :return: QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_fee_v1_incentivized_packet_with_http_info(packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_fee_v1_incentivized_packet_with_http_info(packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs)  # noqa: E501
            return data

    def ibc_applications_fee_v1_incentivized_packet_with_http_info(self, packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs):  # noqa: E501
        """IncentivizedPacket returns all packet fees for a packet given its identifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_incentivized_packet_with_http_info(packet_id_channel_id, packet_id_port_id, packet_id_sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str packet_id_channel_id: channel unique identifier (required)
        :param str packet_id_port_id: channel port identifier (required)
        :param str packet_id_sequence: packet sequence (required)
        :param str query_height: block height at which to query
        :return: QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['packet_id_channel_id', 'packet_id_port_id', 'packet_id_sequence', 'query_height']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_fee_v1_incentivized_packet" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'packet_id_channel_id' is set
        if ('packet_id_channel_id' not in params or
                params['packet_id_channel_id'] is None):
            raise ValueError("Missing the required parameter `packet_id_channel_id` when calling `ibc_applications_fee_v1_incentivized_packet`")  # noqa: E501
        # verify the required parameter 'packet_id_port_id' is set
        if ('packet_id_port_id' not in params or
                params['packet_id_port_id'] is None):
            raise ValueError("Missing the required parameter `packet_id_port_id` when calling `ibc_applications_fee_v1_incentivized_packet`")  # noqa: E501
        # verify the required parameter 'packet_id_sequence' is set
        if ('packet_id_sequence' not in params or
                params['packet_id_sequence'] is None):
            raise ValueError("Missing the required parameter `packet_id_sequence` when calling `ibc_applications_fee_v1_incentivized_packet`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'packet_id_channel_id' in params:
            path_params['packet_id.channel_id'] = params['packet_id_channel_id']  # noqa: E501
        if 'packet_id_port_id' in params:
            path_params['packet_id.port_id'] = params['packet_id_port_id']  # noqa: E501
        if 'packet_id_sequence' in params:
            path_params['packet_id.sequence'] = params['packet_id_sequence']  # noqa: E501

        query_params = []
        if 'query_height' in params:
            query_params.append(('query_height', params['query_height']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/incentivized_packet', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketRpc',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_fee_v1_incentivized_packets(self, **kwargs):  # noqa: E501
        """IncentivizedPackets returns all incentivized packets and their associated fees  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_incentivized_packets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :param str query_height: block height at which to query
        :return: QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_fee_v1_incentivized_packets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_fee_v1_incentivized_packets_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_applications_fee_v1_incentivized_packets_with_http_info(self, **kwargs):  # noqa: E501
        """IncentivizedPackets returns all incentivized packets and their associated fees  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_incentivized_packets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :param str query_height: block height at which to query
        :return: QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse', 'query_height']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_fee_v1_incentivized_packets" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501
        if 'query_height' in params:
            query_params.append(('query_height', params['query_height']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/fee/v1/incentivized_packets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRpc',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_fee_v1_incentivized_packets_for_channel(self, channel_id, port_id, **kwargs):  # noqa: E501
        """Gets all incentivized packets for a specific channel  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_incentivized_packets_for_channel(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: (required)
        :param str port_id: (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :param str query_height: Height to query at
        :return: QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRPC
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_fee_v1_incentivized_packets_for_channel_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_fee_v1_incentivized_packets_for_channel_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
            return data

    def ibc_applications_fee_v1_incentivized_packets_for_channel_with_http_info(self, channel_id, port_id, **kwargs):  # noqa: E501
        """Gets all incentivized packets for a specific channel  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_incentivized_packets_for_channel_with_http_info(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: (required)
        :param str port_id: (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :param str query_height: Height to query at
        :return: QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRPC
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse', 'query_height']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_fee_v1_incentivized_packets_for_channel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_applications_fee_v1_incentivized_packets_for_channel`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_applications_fee_v1_incentivized_packets_for_channel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501
        if 'query_height' in params:
            query_params.append(('query_height', params['query_height']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/fee/v1/channels/{channel_id}/ports/{port_id}/incentivized_packets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRPC',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_fee_v1_payee(self, channel_id, relayer, **kwargs):  # noqa: E501
        """Payee returns the registered payee address for a specific channel given the relayer address  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_payee(channel_id, relayer, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: unique channel identifier (required)
        :param str relayer: the relayer address to which the distribution address is registered (required)
        :return: QueryPayeeResponseDefinesTheResponseTypeForThePayeeRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_fee_v1_payee_with_http_info(channel_id, relayer, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_fee_v1_payee_with_http_info(channel_id, relayer, **kwargs)  # noqa: E501
            return data

    def ibc_applications_fee_v1_payee_with_http_info(self, channel_id, relayer, **kwargs):  # noqa: E501
        """Payee returns the registered payee address for a specific channel given the relayer address  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_payee_with_http_info(channel_id, relayer, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: unique channel identifier (required)
        :param str relayer: the relayer address to which the distribution address is registered (required)
        :return: QueryPayeeResponseDefinesTheResponseTypeForThePayeeRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'relayer']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_fee_v1_payee" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_applications_fee_v1_payee`")  # noqa: E501
        # verify the required parameter 'relayer' is set
        if ('relayer' not in params or
                params['relayer'] is None):
            raise ValueError("Missing the required parameter `relayer` when calling `ibc_applications_fee_v1_payee`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'relayer' in params:
            path_params['relayer'] = params['relayer']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/fee/v1/channels/{channel_id}/relayers/{relayer}/payee', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPayeeResponseDefinesTheResponseTypeForThePayeeRpc',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_fee_v1_total_ack_fees(self, packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs):  # noqa: E501
        """TotalAckFees returns the total acknowledgement fees for a packet given its identifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_total_ack_fees(packet_id_channel_id, packet_id_port_id, packet_id_sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str packet_id_channel_id: channel unique identifier (required)
        :param str packet_id_port_id: channel port identifier (required)
        :param str packet_id_sequence: packet sequence (required)
        :return: QueryTotalAckFeesResponseDefinesTheResponseTypeForTheTotalAckFeesRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_fee_v1_total_ack_fees_with_http_info(packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_fee_v1_total_ack_fees_with_http_info(packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs)  # noqa: E501
            return data

    def ibc_applications_fee_v1_total_ack_fees_with_http_info(self, packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs):  # noqa: E501
        """TotalAckFees returns the total acknowledgement fees for a packet given its identifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_total_ack_fees_with_http_info(packet_id_channel_id, packet_id_port_id, packet_id_sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str packet_id_channel_id: channel unique identifier (required)
        :param str packet_id_port_id: channel port identifier (required)
        :param str packet_id_sequence: packet sequence (required)
        :return: QueryTotalAckFeesResponseDefinesTheResponseTypeForTheTotalAckFeesRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['packet_id_channel_id', 'packet_id_port_id', 'packet_id_sequence']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_fee_v1_total_ack_fees" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'packet_id_channel_id' is set
        if ('packet_id_channel_id' not in params or
                params['packet_id_channel_id'] is None):
            raise ValueError("Missing the required parameter `packet_id_channel_id` when calling `ibc_applications_fee_v1_total_ack_fees`")  # noqa: E501
        # verify the required parameter 'packet_id_port_id' is set
        if ('packet_id_port_id' not in params or
                params['packet_id_port_id'] is None):
            raise ValueError("Missing the required parameter `packet_id_port_id` when calling `ibc_applications_fee_v1_total_ack_fees`")  # noqa: E501
        # verify the required parameter 'packet_id_sequence' is set
        if ('packet_id_sequence' not in params or
                params['packet_id_sequence'] is None):
            raise ValueError("Missing the required parameter `packet_id_sequence` when calling `ibc_applications_fee_v1_total_ack_fees`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'packet_id_channel_id' in params:
            path_params['packet_id.channel_id'] = params['packet_id_channel_id']  # noqa: E501
        if 'packet_id_port_id' in params:
            path_params['packet_id.port_id'] = params['packet_id_port_id']  # noqa: E501
        if 'packet_id_sequence' in params:
            path_params['packet_id.sequence'] = params['packet_id_sequence']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_ack_fees', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryTotalAckFeesResponseDefinesTheResponseTypeForTheTotalAckFeesRpc',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_fee_v1_total_recv_fees(self, packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs):  # noqa: E501
        """TotalRecvFees returns the total receive fees for a packet given its identifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_total_recv_fees(packet_id_channel_id, packet_id_port_id, packet_id_sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str packet_id_channel_id: channel unique identifier (required)
        :param str packet_id_port_id: channel port identifier (required)
        :param str packet_id_sequence: packet sequence (required)
        :return: QueryTotalRecvFeesResponseDefinesTheResponseTypeForTheTotalRecvFeesRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_fee_v1_total_recv_fees_with_http_info(packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_fee_v1_total_recv_fees_with_http_info(packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs)  # noqa: E501
            return data

    def ibc_applications_fee_v1_total_recv_fees_with_http_info(self, packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs):  # noqa: E501
        """TotalRecvFees returns the total receive fees for a packet given its identifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_total_recv_fees_with_http_info(packet_id_channel_id, packet_id_port_id, packet_id_sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str packet_id_channel_id: channel unique identifier (required)
        :param str packet_id_port_id: channel port identifier (required)
        :param str packet_id_sequence: packet sequence (required)
        :return: QueryTotalRecvFeesResponseDefinesTheResponseTypeForTheTotalRecvFeesRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['packet_id_channel_id', 'packet_id_port_id', 'packet_id_sequence']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_fee_v1_total_recv_fees" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'packet_id_channel_id' is set
        if ('packet_id_channel_id' not in params or
                params['packet_id_channel_id'] is None):
            raise ValueError("Missing the required parameter `packet_id_channel_id` when calling `ibc_applications_fee_v1_total_recv_fees`")  # noqa: E501
        # verify the required parameter 'packet_id_port_id' is set
        if ('packet_id_port_id' not in params or
                params['packet_id_port_id'] is None):
            raise ValueError("Missing the required parameter `packet_id_port_id` when calling `ibc_applications_fee_v1_total_recv_fees`")  # noqa: E501
        # verify the required parameter 'packet_id_sequence' is set
        if ('packet_id_sequence' not in params or
                params['packet_id_sequence'] is None):
            raise ValueError("Missing the required parameter `packet_id_sequence` when calling `ibc_applications_fee_v1_total_recv_fees`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'packet_id_channel_id' in params:
            path_params['packet_id.channel_id'] = params['packet_id_channel_id']  # noqa: E501
        if 'packet_id_port_id' in params:
            path_params['packet_id.port_id'] = params['packet_id_port_id']  # noqa: E501
        if 'packet_id_sequence' in params:
            path_params['packet_id.sequence'] = params['packet_id_sequence']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_recv_fees', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryTotalRecvFeesResponseDefinesTheResponseTypeForTheTotalRecvFeesRpc',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_fee_v1_total_timeout_fees(self, packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs):  # noqa: E501
        """TotalTimeoutFees returns the total timeout fees for a packet given its identifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_total_timeout_fees(packet_id_channel_id, packet_id_port_id, packet_id_sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str packet_id_channel_id: channel unique identifier (required)
        :param str packet_id_port_id: channel port identifier (required)
        :param str packet_id_sequence: packet sequence (required)
        :return: QueryTotalTimeoutFeesResponseDefinesTheResponseTypeForTheTotalTimeoutFeesRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_fee_v1_total_timeout_fees_with_http_info(packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_fee_v1_total_timeout_fees_with_http_info(packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs)  # noqa: E501
            return data

    def ibc_applications_fee_v1_total_timeout_fees_with_http_info(self, packet_id_channel_id, packet_id_port_id, packet_id_sequence, **kwargs):  # noqa: E501
        """TotalTimeoutFees returns the total timeout fees for a packet given its identifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_fee_v1_total_timeout_fees_with_http_info(packet_id_channel_id, packet_id_port_id, packet_id_sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str packet_id_channel_id: channel unique identifier (required)
        :param str packet_id_port_id: channel port identifier (required)
        :param str packet_id_sequence: packet sequence (required)
        :return: QueryTotalTimeoutFeesResponseDefinesTheResponseTypeForTheTotalTimeoutFeesRpc
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['packet_id_channel_id', 'packet_id_port_id', 'packet_id_sequence']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_fee_v1_total_timeout_fees" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'packet_id_channel_id' is set
        if ('packet_id_channel_id' not in params or
                params['packet_id_channel_id'] is None):
            raise ValueError("Missing the required parameter `packet_id_channel_id` when calling `ibc_applications_fee_v1_total_timeout_fees`")  # noqa: E501
        # verify the required parameter 'packet_id_port_id' is set
        if ('packet_id_port_id' not in params or
                params['packet_id_port_id'] is None):
            raise ValueError("Missing the required parameter `packet_id_port_id` when calling `ibc_applications_fee_v1_total_timeout_fees`")  # noqa: E501
        # verify the required parameter 'packet_id_sequence' is set
        if ('packet_id_sequence' not in params or
                params['packet_id_sequence'] is None):
            raise ValueError("Missing the required parameter `packet_id_sequence` when calling `ibc_applications_fee_v1_total_timeout_fees`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'packet_id_channel_id' in params:
            path_params['packet_id.channel_id'] = params['packet_id_channel_id']  # noqa: E501
        if 'packet_id_port_id' in params:
            path_params['packet_id.port_id'] = params['packet_id_port_id']  # noqa: E501
        if 'packet_id_sequence' in params:
            path_params['packet_id.sequence'] = params['packet_id_sequence']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_timeout_fees', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryTotalTimeoutFeesResponseDefinesTheResponseTypeForTheTotalTimeoutFeesRpc',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_interchain_accounts_controller_v1_interchain_account(self, owner, connection_id, **kwargs):  # noqa: E501
        """InterchainAccount returns the interchain account address for a given owner address on a given connection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_interchain_accounts_controller_v1_interchain_account(owner, connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: (required)
        :param str connection_id: (required)
        :return: InlineResponse20090
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_interchain_accounts_controller_v1_interchain_account_with_http_info(owner, connection_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_interchain_accounts_controller_v1_interchain_account_with_http_info(owner, connection_id, **kwargs)  # noqa: E501
            return data

    def ibc_applications_interchain_accounts_controller_v1_interchain_account_with_http_info(self, owner, connection_id, **kwargs):  # noqa: E501
        """InterchainAccount returns the interchain account address for a given owner address on a given connection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_interchain_accounts_controller_v1_interchain_account_with_http_info(owner, connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: (required)
        :param str connection_id: (required)
        :return: InlineResponse20090
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner', 'connection_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_interchain_accounts_controller_v1_interchain_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner' is set
        if ('owner' not in params or
                params['owner'] is None):
            raise ValueError("Missing the required parameter `owner` when calling `ibc_applications_interchain_accounts_controller_v1_interchain_account`")  # noqa: E501
        # verify the required parameter 'connection_id' is set
        if ('connection_id' not in params or
                params['connection_id'] is None):
            raise ValueError("Missing the required parameter `connection_id` when calling `ibc_applications_interchain_accounts_controller_v1_interchain_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in params:
            path_params['owner'] = params['owner']  # noqa: E501
        if 'connection_id' in params:
            path_params['connection_id'] = params['connection_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/interchain_accounts/controller/v1/owners/{owner}/connections/{connection_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20090',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_interchain_accounts_controller_v1_params(self, **kwargs):  # noqa: E501
        """Params queries all parameters of the ICA controller submodule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_interchain_accounts_controller_v1_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20091
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_interchain_accounts_controller_v1_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_interchain_accounts_controller_v1_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_applications_interchain_accounts_controller_v1_params_with_http_info(self, **kwargs):  # noqa: E501
        """Params queries all parameters of the ICA controller submodule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_interchain_accounts_controller_v1_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20091
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_interchain_accounts_controller_v1_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/interchain_accounts/controller/v1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20091',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_interchain_accounts_host_v1_params(self, **kwargs):  # noqa: E501
        """Params queries all parameters of the ICA host submodule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_interchain_accounts_host_v1_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20092
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_interchain_accounts_host_v1_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_interchain_accounts_host_v1_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_applications_interchain_accounts_host_v1_params_with_http_info(self, **kwargs):  # noqa: E501
        """Params queries all parameters of the ICA host submodule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_interchain_accounts_host_v1_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20092
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_interchain_accounts_host_v1_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/interchain_accounts/host/v1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20092',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_transfer_v1_denom_hash(self, trace, **kwargs):  # noqa: E501
        """DenomHash queries a denomination hash information.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_transfer_v1_denom_hash(trace, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trace: The denomination trace ([port_id]/[channel_id])+/[denom] (required)
        :return: InlineResponse20094
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_transfer_v1_denom_hash_with_http_info(trace, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_transfer_v1_denom_hash_with_http_info(trace, **kwargs)  # noqa: E501
            return data

    def ibc_applications_transfer_v1_denom_hash_with_http_info(self, trace, **kwargs):  # noqa: E501
        """DenomHash queries a denomination hash information.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_transfer_v1_denom_hash_with_http_info(trace, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trace: The denomination trace ([port_id]/[channel_id])+/[denom] (required)
        :return: InlineResponse20094
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['trace']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_transfer_v1_denom_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'trace' is set
        if ('trace' not in params or
                params['trace'] is None):
            raise ValueError("Missing the required parameter `trace` when calling `ibc_applications_transfer_v1_denom_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'trace' in params:
            path_params['trace'] = params['trace']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/transfer/v1/denom_hashes/{trace}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20094',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_transfer_v1_denom_trace(self, hash, **kwargs):  # noqa: E501
        """DenomTrace queries a denomination trace information.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_transfer_v1_denom_trace(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information. (required)
        :return: InlineResponse20096
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_transfer_v1_denom_trace_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_transfer_v1_denom_trace_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def ibc_applications_transfer_v1_denom_trace_with_http_info(self, hash, **kwargs):  # noqa: E501
        """DenomTrace queries a denomination trace information.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_transfer_v1_denom_trace_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information. (required)
        :return: InlineResponse20096
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_transfer_v1_denom_trace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `ibc_applications_transfer_v1_denom_trace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/transfer/v1/denom_traces/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20096',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_transfer_v1_denom_traces(self, **kwargs):  # noqa: E501
        """DenomTraces queries all denomination traces.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_transfer_v1_denom_traces(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20095
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_transfer_v1_denom_traces_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_transfer_v1_denom_traces_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_applications_transfer_v1_denom_traces_with_http_info(self, **kwargs):  # noqa: E501
        """DenomTraces queries all denomination traces.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_transfer_v1_denom_traces_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20095
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_transfer_v1_denom_traces" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/transfer/v1/denom_traces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20095',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_transfer_v1_escrow_address(self, channel_id, port_id, **kwargs):  # noqa: E501
        """EscrowAddress returns the escrow address for a particular port and channel id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_transfer_v1_escrow_address(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: unique channel identifier (required)
        :param str port_id: unique port identifier (required)
        :return: InlineResponse20093
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_transfer_v1_escrow_address_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_transfer_v1_escrow_address_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
            return data

    def ibc_applications_transfer_v1_escrow_address_with_http_info(self, channel_id, port_id, **kwargs):  # noqa: E501
        """EscrowAddress returns the escrow address for a particular port and channel id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_transfer_v1_escrow_address_with_http_info(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: unique channel identifier (required)
        :param str port_id: unique port identifier (required)
        :return: InlineResponse20093
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_transfer_v1_escrow_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_applications_transfer_v1_escrow_address`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_applications_transfer_v1_escrow_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20093',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_transfer_v1_params(self, **kwargs):  # noqa: E501
        """Params queries all parameters of the ibc-transfer module.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_transfer_v1_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20098
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_transfer_v1_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_transfer_v1_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_applications_transfer_v1_params_with_http_info(self, **kwargs):  # noqa: E501
        """Params queries all parameters of the ibc-transfer module.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_transfer_v1_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20098
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_transfer_v1_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/transfer/v1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20098',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_applications_transfer_v1_total_escrow_for_denom(self, denom, **kwargs):  # noqa: E501
        """TotalEscrowForDenom returns the total amount of tokens in escrow based on the denom.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_transfer_v1_total_escrow_for_denom(denom, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str denom: (required)
        :return: InlineResponse20097
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_applications_transfer_v1_total_escrow_for_denom_with_http_info(denom, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_applications_transfer_v1_total_escrow_for_denom_with_http_info(denom, **kwargs)  # noqa: E501
            return data

    def ibc_applications_transfer_v1_total_escrow_for_denom_with_http_info(self, denom, **kwargs):  # noqa: E501
        """TotalEscrowForDenom returns the total amount of tokens in escrow based on the denom.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_applications_transfer_v1_total_escrow_for_denom_with_http_info(denom, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str denom: (required)
        :return: InlineResponse20097
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['denom']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_applications_transfer_v1_total_escrow_for_denom" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'denom' is set
        if ('denom' not in params or
                params['denom'] is None):
            raise ValueError("Missing the required parameter `denom` when calling `ibc_applications_transfer_v1_total_escrow_for_denom`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'denom' in params:
            path_params['denom'] = params['denom']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/apps/transfer/v1/denoms/{denom}/total_escrow', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20097',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_channel(self, channel_id, port_id, **kwargs):  # noqa: E501
        """Channel queries an IBC Channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_channel(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :return: InlineResponse200100
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_channel_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_channel_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_channel_with_http_info(self, channel_id, port_id, **kwargs):  # noqa: E501
        """Channel queries an IBC Channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_channel_with_http_info(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :return: InlineResponse200100
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_channel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_core_channel_v1_channel`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_core_channel_v1_channel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200100',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_channel_client_state(self, channel_id, port_id, **kwargs):  # noqa: E501
        """ChannelClientState queries for the client state for the channel associated with the provided channel identifiers.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_channel_client_state(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :return: QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_channel_client_state_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_channel_client_state_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_channel_client_state_with_http_info(self, channel_id, port_id, **kwargs):  # noqa: E501
        """ChannelClientState queries for the client state for the channel associated with the provided channel identifiers.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_channel_client_state_with_http_info(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :return: QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_channel_client_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_core_channel_v1_channel_client_state`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_core_channel_v1_channel_client_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_channel_consensus_state(self, channel_id, port_id, revision_number, revision_height, **kwargs):  # noqa: E501
        """ChannelConsensusState queries for the consensus state for the channel associated with the provided channel identifiers.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_channel_consensus_state(channel_id, port_id, revision_number, revision_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param str revision_number: revision number of the consensus state (required)
        :param str revision_height: revision height of the consensus state (required)
        :return: QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_channel_consensus_state_with_http_info(channel_id, port_id, revision_number, revision_height, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_channel_consensus_state_with_http_info(channel_id, port_id, revision_number, revision_height, **kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_channel_consensus_state_with_http_info(self, channel_id, port_id, revision_number, revision_height, **kwargs):  # noqa: E501
        """ChannelConsensusState queries for the consensus state for the channel associated with the provided channel identifiers.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_channel_consensus_state_with_http_info(channel_id, port_id, revision_number, revision_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param str revision_number: revision number of the consensus state (required)
        :param str revision_height: revision height of the consensus state (required)
        :return: QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id', 'revision_number', 'revision_height']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_channel_consensus_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_core_channel_v1_channel_consensus_state`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_core_channel_v1_channel_consensus_state`")  # noqa: E501
        # verify the required parameter 'revision_number' is set
        if ('revision_number' not in params or
                params['revision_number'] is None):
            raise ValueError("Missing the required parameter `revision_number` when calling `ibc_core_channel_v1_channel_consensus_state`")  # noqa: E501
        # verify the required parameter 'revision_height' is set
        if ('revision_height' not in params or
                params['revision_height'] is None):
            raise ValueError("Missing the required parameter `revision_height` when calling `ibc_core_channel_v1_channel_consensus_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501
        if 'revision_number' in params:
            path_params['revision_number'] = params['revision_number']  # noqa: E501
        if 'revision_height' in params:
            path_params['revision_height'] = params['revision_height']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_channels(self, **kwargs):  # noqa: E501
        """Channels queries all the IBC channels of a chain.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_channels(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20099
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_channels_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_channels_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_channels_with_http_info(self, **kwargs):  # noqa: E501
        """Channels queries all the IBC channels of a chain.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_channels_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse20099
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_channels" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/channels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20099',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_connection_channels(self, connection, **kwargs):  # noqa: E501
        """ConnectionChannels queries all the channels associated with a connection end.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_connection_channels(connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connection: connection unique identifier (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_connection_channels_with_http_info(connection, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_connection_channels_with_http_info(connection, **kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_connection_channels_with_http_info(self, connection, **kwargs):  # noqa: E501
        """ConnectionChannels queries all the channels associated with a connection end.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_connection_channels_with_http_info(connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connection: connection unique identifier (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connection', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_connection_channels" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'connection' is set
        if ('connection' not in params or
                params['connection'] is None):
            raise ValueError("Missing the required parameter `connection` when calling `ibc_core_channel_v1_connection_channels`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection' in params:
            path_params['connection'] = params['connection']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/connections/{connection}/channels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_next_sequence_receive(self, channel_id, port_id, **kwargs):  # noqa: E501
        """NextSequenceReceive returns the next receive sequence for a given channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_next_sequence_receive(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :return: QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_next_sequence_receive_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_next_sequence_receive_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_next_sequence_receive_with_http_info(self, channel_id, port_id, **kwargs):  # noqa: E501
        """NextSequenceReceive returns the next receive sequence for a given channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_next_sequence_receive_with_http_info(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :return: QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_next_sequence_receive" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_core_channel_v1_next_sequence_receive`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_core_channel_v1_next_sequence_receive`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_packet_acknowledgement(self, channel_id, port_id, sequence, **kwargs):  # noqa: E501
        """PacketAcknowledgement queries a stored packet acknowledgement hash.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_packet_acknowledgement(channel_id, port_id, sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param str sequence: packet sequence (required)
        :return: QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForApacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheproofWasRetrieved
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_packet_acknowledgement_with_http_info(channel_id, port_id, sequence, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_packet_acknowledgement_with_http_info(channel_id, port_id, sequence, **kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_packet_acknowledgement_with_http_info(self, channel_id, port_id, sequence, **kwargs):  # noqa: E501
        """PacketAcknowledgement queries a stored packet acknowledgement hash.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_packet_acknowledgement_with_http_info(channel_id, port_id, sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param str sequence: packet sequence (required)
        :return: QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForApacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheproofWasRetrieved
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id', 'sequence']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_packet_acknowledgement" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_core_channel_v1_packet_acknowledgement`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_core_channel_v1_packet_acknowledgement`")  # noqa: E501
        # verify the required parameter 'sequence' is set
        if ('sequence' not in params or
                params['sequence'] is None):
            raise ValueError("Missing the required parameter `sequence` when calling `ibc_core_channel_v1_packet_acknowledgement`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501
        if 'sequence' in params:
            path_params['sequence'] = params['sequence']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForApacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheproofWasRetrieved',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_packet_acknowledgements(self, channel_id, port_id, **kwargs):  # noqa: E501
        """PacketAcknowledgements returns all the packet acknowledgements associated with a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_packet_acknowledgements(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :param list[str] packet_commitment_sequences: list of packet sequences
        :return: QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_packet_acknowledgements_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_packet_acknowledgements_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_packet_acknowledgements_with_http_info(self, channel_id, port_id, **kwargs):  # noqa: E501
        """PacketAcknowledgements returns all the packet acknowledgements associated with a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_packet_acknowledgements_with_http_info(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :param list[str] packet_commitment_sequences: list of packet sequences
        :return: QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse', 'packet_commitment_sequences']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_packet_acknowledgements" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_core_channel_v1_packet_acknowledgements`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_core_channel_v1_packet_acknowledgements`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501
        if 'packet_commitment_sequences' in params:
            query_params.append(('packet_commitment_sequences', params['packet_commitment_sequences']))  # noqa: E501
            collection_formats['packet_commitment_sequences'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_packet_commitment(self, channel_id, port_id, sequence, **kwargs):  # noqa: E501
        """PacketCommitment queries a stored packet commitment hash.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_packet_commitment(channel_id, port_id, sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param str sequence: packet sequence (required)
        :return: QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketwhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasretrieved
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_packet_commitment_with_http_info(channel_id, port_id, sequence, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_packet_commitment_with_http_info(channel_id, port_id, sequence, **kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_packet_commitment_with_http_info(self, channel_id, port_id, sequence, **kwargs):  # noqa: E501
        """PacketCommitment queries a stored packet commitment hash.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_packet_commitment_with_http_info(channel_id, port_id, sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param str sequence: packet sequence (required)
        :return: QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketwhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasretrieved
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id', 'sequence']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_packet_commitment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_core_channel_v1_packet_commitment`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_core_channel_v1_packet_commitment`")  # noqa: E501
        # verify the required parameter 'sequence' is set
        if ('sequence' not in params or
                params['sequence'] is None):
            raise ValueError("Missing the required parameter `sequence` when calling `ibc_core_channel_v1_packet_commitment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501
        if 'sequence' in params:
            path_params['sequence'] = params['sequence']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketwhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasretrieved',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_packet_commitments(self, channel_id, port_id, **kwargs):  # noqa: E501
        """PacketCommitments returns all the packet commitments hashes associated with a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_packet_commitments(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_packet_commitments_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_packet_commitments_with_http_info(channel_id, port_id, **kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_packet_commitments_with_http_info(self, channel_id, port_id, **kwargs):  # noqa: E501
        """PacketCommitments returns all the packet commitments hashes associated with a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_packet_commitments_with_http_info(channel_id, port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_packet_commitments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_core_channel_v1_packet_commitments`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_core_channel_v1_packet_commitments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_packet_receipt(self, channel_id, port_id, sequence, **kwargs):  # noqa: E501
        """PacketReceipt queries if a given packet sequence has been received on the queried chain  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_packet_receipt(channel_id, port_id, sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param str sequence: packet sequence (required)
        :return: QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketreceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasretrieved
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_packet_receipt_with_http_info(channel_id, port_id, sequence, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_packet_receipt_with_http_info(channel_id, port_id, sequence, **kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_packet_receipt_with_http_info(self, channel_id, port_id, sequence, **kwargs):  # noqa: E501
        """PacketReceipt queries if a given packet sequence has been received on the queried chain  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_packet_receipt_with_http_info(channel_id, port_id, sequence, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param str sequence: packet sequence (required)
        :return: QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketreceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasretrieved
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id', 'sequence']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_packet_receipt" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_core_channel_v1_packet_receipt`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_core_channel_v1_packet_receipt`")  # noqa: E501
        # verify the required parameter 'sequence' is set
        if ('sequence' not in params or
                params['sequence'] is None):
            raise ValueError("Missing the required parameter `sequence` when calling `ibc_core_channel_v1_packet_receipt`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501
        if 'sequence' in params:
            path_params['sequence'] = params['sequence']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketreceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasretrieved',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_unreceived_acks(self, channel_id, port_id, packet_ack_sequences, **kwargs):  # noqa: E501
        """UnreceivedAcks returns all the unreceived IBC acknowledgements associated with a channel and sequences.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_unreceived_acks(channel_id, port_id, packet_ack_sequences, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param list[str] packet_ack_sequences: list of acknowledgement sequences (required)
        :return: QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_unreceived_acks_with_http_info(channel_id, port_id, packet_ack_sequences, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_unreceived_acks_with_http_info(channel_id, port_id, packet_ack_sequences, **kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_unreceived_acks_with_http_info(self, channel_id, port_id, packet_ack_sequences, **kwargs):  # noqa: E501
        """UnreceivedAcks returns all the unreceived IBC acknowledgements associated with a channel and sequences.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_unreceived_acks_with_http_info(channel_id, port_id, packet_ack_sequences, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param list[str] packet_ack_sequences: list of acknowledgement sequences (required)
        :return: QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id', 'packet_ack_sequences']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_unreceived_acks" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_core_channel_v1_unreceived_acks`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_core_channel_v1_unreceived_acks`")  # noqa: E501
        # verify the required parameter 'packet_ack_sequences' is set
        if ('packet_ack_sequences' not in params or
                params['packet_ack_sequences'] is None):
            raise ValueError("Missing the required parameter `packet_ack_sequences` when calling `ibc_core_channel_v1_unreceived_acks`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501
        if 'packet_ack_sequences' in params:
            path_params['packet_ack_sequences'] = params['packet_ack_sequences']  # noqa: E501
            collection_formats['packet_ack_sequences'] = ''  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_channel_v1_unreceived_packets(self, channel_id, port_id, packet_commitment_sequences, **kwargs):  # noqa: E501
        """UnreceivedPackets returns all the unreceived IBC packets associated with a channel and sequences.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_unreceived_packets(channel_id, port_id, packet_commitment_sequences, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param list[str] packet_commitment_sequences: list of packet sequences (required)
        :return: QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_channel_v1_unreceived_packets_with_http_info(channel_id, port_id, packet_commitment_sequences, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_channel_v1_unreceived_packets_with_http_info(channel_id, port_id, packet_commitment_sequences, **kwargs)  # noqa: E501
            return data

    def ibc_core_channel_v1_unreceived_packets_with_http_info(self, channel_id, port_id, packet_commitment_sequences, **kwargs):  # noqa: E501
        """UnreceivedPackets returns all the unreceived IBC packets associated with a channel and sequences.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_channel_v1_unreceived_packets_with_http_info(channel_id, port_id, packet_commitment_sequences, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: channel unique identifier (required)
        :param str port_id: port unique identifier (required)
        :param list[str] packet_commitment_sequences: list of packet sequences (required)
        :return: QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'port_id', 'packet_commitment_sequences']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_channel_v1_unreceived_packets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `ibc_core_channel_v1_unreceived_packets`")  # noqa: E501
        # verify the required parameter 'port_id' is set
        if ('port_id' not in params or
                params['port_id'] is None):
            raise ValueError("Missing the required parameter `port_id` when calling `ibc_core_channel_v1_unreceived_packets`")  # noqa: E501
        # verify the required parameter 'packet_commitment_sequences' is set
        if ('packet_commitment_sequences' not in params or
                params['packet_commitment_sequences'] is None):
            raise ValueError("Missing the required parameter `packet_commitment_sequences` when calling `ibc_core_channel_v1_unreceived_packets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channel_id'] = params['channel_id']  # noqa: E501
        if 'port_id' in params:
            path_params['port_id'] = params['port_id']  # noqa: E501
        if 'packet_commitment_sequences' in params:
            path_params['packet_commitment_sequences'] = params['packet_commitment_sequences']  # noqa: E501
            collection_formats['packet_commitment_sequences'] = ''  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_client_v1_client_params(self, **kwargs):  # noqa: E501
        """ClientParams queries all parameters of the ibc client submodule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_client_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200104
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_client_v1_client_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_client_v1_client_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_core_client_v1_client_params_with_http_info(self, **kwargs):  # noqa: E501
        """ClientParams queries all parameters of the ibc client submodule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_client_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200104
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_client_v1_client_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/client/v1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200104',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_client_v1_client_state(self, client_id, **kwargs):  # noqa: E501
        """ClientState queries an IBC light client.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_client_state(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: client state unique identifier (required)
        :return: InlineResponse200102
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_client_v1_client_state_with_http_info(client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_client_v1_client_state_with_http_info(client_id, **kwargs)  # noqa: E501
            return data

    def ibc_core_client_v1_client_state_with_http_info(self, client_id, **kwargs):  # noqa: E501
        """ClientState queries an IBC light client.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_client_state_with_http_info(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: client state unique identifier (required)
        :return: InlineResponse200102
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_client_v1_client_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `ibc_core_client_v1_client_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/client/v1/client_states/{client_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200102',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_client_v1_client_states(self, **kwargs):  # noqa: E501
        """ClientStates queries all the IBC light clients of a chain.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_client_states(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse200101
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_client_v1_client_states_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_client_v1_client_states_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_core_client_v1_client_states_with_http_info(self, **kwargs):  # noqa: E501
        """ClientStates queries all the IBC light clients of a chain.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_client_states_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse200101
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_client_v1_client_states" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/client/v1/client_states', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200101',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_client_v1_client_status(self, client_id, **kwargs):  # noqa: E501
        """Status queries the status of an IBC client.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_client_status(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: client unique identifier (required)
        :return: InlineResponse200103
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_client_v1_client_status_with_http_info(client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_client_v1_client_status_with_http_info(client_id, **kwargs)  # noqa: E501
            return data

    def ibc_core_client_v1_client_status_with_http_info(self, client_id, **kwargs):  # noqa: E501
        """Status queries the status of an IBC client.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_client_status_with_http_info(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: client unique identifier (required)
        :return: InlineResponse200103
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_client_v1_client_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `ibc_core_client_v1_client_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/client/v1/client_status/{client_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200103',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_client_v1_consensus_state(self, client_id, revision_number, revision_height, **kwargs):  # noqa: E501
        """ConsensusState queries a consensus state associated with a client state at a given height.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_consensus_state(client_id, revision_number, revision_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: client identifier (required)
        :param str revision_number: consensus state revision number (required)
        :param str revision_height: consensus state revision height (required)
        :param bool latest_height: latest_height overrrides the height field and queries the latest stored ConsensusState
        :return: QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_client_v1_consensus_state_with_http_info(client_id, revision_number, revision_height, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_client_v1_consensus_state_with_http_info(client_id, revision_number, revision_height, **kwargs)  # noqa: E501
            return data

    def ibc_core_client_v1_consensus_state_with_http_info(self, client_id, revision_number, revision_height, **kwargs):  # noqa: E501
        """ConsensusState queries a consensus state associated with a client state at a given height.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_consensus_state_with_http_info(client_id, revision_number, revision_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: client identifier (required)
        :param str revision_number: consensus state revision number (required)
        :param str revision_height: consensus state revision height (required)
        :param bool latest_height: latest_height overrrides the height field and queries the latest stored ConsensusState
        :return: QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'revision_number', 'revision_height', 'latest_height']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_client_v1_consensus_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `ibc_core_client_v1_consensus_state`")  # noqa: E501
        # verify the required parameter 'revision_number' is set
        if ('revision_number' not in params or
                params['revision_number'] is None):
            raise ValueError("Missing the required parameter `revision_number` when calling `ibc_core_client_v1_consensus_state`")  # noqa: E501
        # verify the required parameter 'revision_height' is set
        if ('revision_height' not in params or
                params['revision_height'] is None):
            raise ValueError("Missing the required parameter `revision_height` when calling `ibc_core_client_v1_consensus_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501
        if 'revision_number' in params:
            path_params['revision_number'] = params['revision_number']  # noqa: E501
        if 'revision_height' in params:
            path_params['revision_height'] = params['revision_height']  # noqa: E501

        query_params = []
        if 'latest_height' in params:
            query_params.append(('latest_height', params['latest_height']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_client_v1_consensus_state_heights(self, client_id, **kwargs):  # noqa: E501
        """ConsensusStateHeights queries the height of every consensus states associated with a given client.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_consensus_state_heights(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: client identifier (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryConsensusStateHeightsResponseIsTheResponseTypeForTheQueryConsensusStateHeightsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_client_v1_consensus_state_heights_with_http_info(client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_client_v1_consensus_state_heights_with_http_info(client_id, **kwargs)  # noqa: E501
            return data

    def ibc_core_client_v1_consensus_state_heights_with_http_info(self, client_id, **kwargs):  # noqa: E501
        """ConsensusStateHeights queries the height of every consensus states associated with a given client.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_consensus_state_heights_with_http_info(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: client identifier (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryConsensusStateHeightsResponseIsTheResponseTypeForTheQueryConsensusStateHeightsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_client_v1_consensus_state_heights" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `ibc_core_client_v1_consensus_state_heights`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/client/v1/consensus_states/{client_id}/heights', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryConsensusStateHeightsResponseIsTheResponseTypeForTheQueryConsensusStateHeightsRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_client_v1_consensus_states(self, client_id, **kwargs):  # noqa: E501
        """ConsensusStates queries all the consensus state associated with a given client.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_consensus_states(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: client identifier (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_client_v1_consensus_states_with_http_info(client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_client_v1_consensus_states_with_http_info(client_id, **kwargs)  # noqa: E501
            return data

    def ibc_core_client_v1_consensus_states_with_http_info(self, client_id, **kwargs):  # noqa: E501
        """ConsensusStates queries all the consensus state associated with a given client.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_consensus_states_with_http_info(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: client identifier (required)
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_client_v1_consensus_states" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `ibc_core_client_v1_consensus_states`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/client/v1/consensus_states/{client_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_client_v1_upgraded_client_state(self, **kwargs):  # noqa: E501
        """UpgradedClientState queries an Upgraded IBC light client.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_upgraded_client_state(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200105
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_client_v1_upgraded_client_state_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_client_v1_upgraded_client_state_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_core_client_v1_upgraded_client_state_with_http_info(self, **kwargs):  # noqa: E501
        """UpgradedClientState queries an Upgraded IBC light client.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_upgraded_client_state_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200105
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_client_v1_upgraded_client_state" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/client/v1/upgraded_client_states', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200105',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_client_v1_upgraded_consensus_state(self, **kwargs):  # noqa: E501
        """UpgradedConsensusState queries an Upgraded IBC consensus state.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_upgraded_consensus_state(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200106
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_client_v1_upgraded_consensus_state_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_client_v1_upgraded_consensus_state_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_core_client_v1_upgraded_consensus_state_with_http_info(self, **kwargs):  # noqa: E501
        """UpgradedConsensusState queries an Upgraded IBC consensus state.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_client_v1_upgraded_consensus_state_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200106
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_client_v1_upgraded_consensus_state" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/client/v1/upgraded_consensus_states', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200106',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_connection_v1_client_connections(self, client_id, **kwargs):  # noqa: E501
        """ClientConnections queries the connection paths associated with a client state.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_connection_v1_client_connections(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: client identifier associated with a connection (required)
        :return: QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_connection_v1_client_connections_with_http_info(client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_connection_v1_client_connections_with_http_info(client_id, **kwargs)  # noqa: E501
            return data

    def ibc_core_connection_v1_client_connections_with_http_info(self, client_id, **kwargs):  # noqa: E501
        """ClientConnections queries the connection paths associated with a client state.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_connection_v1_client_connections_with_http_info(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: client identifier associated with a connection (required)
        :return: QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_connection_v1_client_connections" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `ibc_core_connection_v1_client_connections`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/connection/v1/client_connections/{client_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_connection_v1_connection(self, connection_id, **kwargs):  # noqa: E501
        """Connection queries an IBC connection end.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_connection_v1_connection(connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connection_id: connection unique identifier (required)
        :return: InlineResponse200108
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_connection_v1_connection_with_http_info(connection_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_connection_v1_connection_with_http_info(connection_id, **kwargs)  # noqa: E501
            return data

    def ibc_core_connection_v1_connection_with_http_info(self, connection_id, **kwargs):  # noqa: E501
        """Connection queries an IBC connection end.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_connection_v1_connection_with_http_info(connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connection_id: connection unique identifier (required)
        :return: InlineResponse200108
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connection_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_connection_v1_connection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'connection_id' is set
        if ('connection_id' not in params or
                params['connection_id'] is None):
            raise ValueError("Missing the required parameter `connection_id` when calling `ibc_core_connection_v1_connection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in params:
            path_params['connection_id'] = params['connection_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/connection/v1/connections/{connection_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200108',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_connection_v1_connection_client_state(self, connection_id, **kwargs):  # noqa: E501
        """ConnectionClientState queries the client state associated with the connection.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_connection_v1_connection_client_state(connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connection_id: connection identifier (required)
        :return: QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_connection_v1_connection_client_state_with_http_info(connection_id, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_connection_v1_connection_client_state_with_http_info(connection_id, **kwargs)  # noqa: E501
            return data

    def ibc_core_connection_v1_connection_client_state_with_http_info(self, connection_id, **kwargs):  # noqa: E501
        """ConnectionClientState queries the client state associated with the connection.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_connection_v1_connection_client_state_with_http_info(connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connection_id: connection identifier (required)
        :return: QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connection_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_connection_v1_connection_client_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'connection_id' is set
        if ('connection_id' not in params or
                params['connection_id'] is None):
            raise ValueError("Missing the required parameter `connection_id` when calling `ibc_core_connection_v1_connection_client_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in params:
            path_params['connection_id'] = params['connection_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/connection/v1/connections/{connection_id}/client_state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_connection_v1_connection_consensus_state(self, connection_id, revision_number, revision_height, **kwargs):  # noqa: E501
        """ConnectionConsensusState queries the consensus state associated with the connection.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_connection_v1_connection_consensus_state(connection_id, revision_number, revision_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connection_id: connection identifier (required)
        :param str revision_number: (required)
        :param str revision_height: (required)
        :return: QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_connection_v1_connection_consensus_state_with_http_info(connection_id, revision_number, revision_height, **kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_connection_v1_connection_consensus_state_with_http_info(connection_id, revision_number, revision_height, **kwargs)  # noqa: E501
            return data

    def ibc_core_connection_v1_connection_consensus_state_with_http_info(self, connection_id, revision_number, revision_height, **kwargs):  # noqa: E501
        """ConnectionConsensusState queries the consensus state associated with the connection.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_connection_v1_connection_consensus_state_with_http_info(connection_id, revision_number, revision_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connection_id: connection identifier (required)
        :param str revision_number: (required)
        :param str revision_height: (required)
        :return: QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connection_id', 'revision_number', 'revision_height']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_connection_v1_connection_consensus_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'connection_id' is set
        if ('connection_id' not in params or
                params['connection_id'] is None):
            raise ValueError("Missing the required parameter `connection_id` when calling `ibc_core_connection_v1_connection_consensus_state`")  # noqa: E501
        # verify the required parameter 'revision_number' is set
        if ('revision_number' not in params or
                params['revision_number'] is None):
            raise ValueError("Missing the required parameter `revision_number` when calling `ibc_core_connection_v1_connection_consensus_state`")  # noqa: E501
        # verify the required parameter 'revision_height' is set
        if ('revision_height' not in params or
                params['revision_height'] is None):
            raise ValueError("Missing the required parameter `revision_height` when calling `ibc_core_connection_v1_connection_consensus_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in params:
            path_params['connection_id'] = params['connection_id']  # noqa: E501
        if 'revision_number' in params:
            path_params['revision_number'] = params['revision_number']  # noqa: E501
        if 'revision_height' in params:
            path_params['revision_height'] = params['revision_height']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_connection_v1_connection_params(self, **kwargs):  # noqa: E501
        """ConnectionParams queries all parameters of the ibc connection submodule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_connection_v1_connection_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200109
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_connection_v1_connection_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_connection_v1_connection_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_core_connection_v1_connection_params_with_http_info(self, **kwargs):  # noqa: E501
        """ConnectionParams queries all parameters of the ibc connection submodule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_connection_v1_connection_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200109
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_connection_v1_connection_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/connection/v1/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200109',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ibc_core_connection_v1_connections(self, **kwargs):  # noqa: E501
        """Connections queries all the IBC connections of a chain.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_connection_v1_connections(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse200107
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ibc_core_connection_v1_connections_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ibc_core_connection_v1_connections_with_http_info(**kwargs)  # noqa: E501
            return data

    def ibc_core_connection_v1_connections_with_http_info(self, **kwargs):  # noqa: E501
        """Connections queries all the IBC connections of a chain.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ibc_core_connection_v1_connections_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pagination_key: key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
        :param str pagination_offset: offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
        :param str pagination_limit: limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
        :param bool pagination_count_total: count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
        :param bool pagination_reverse: reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
        :return: InlineResponse200107
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pagination_key', 'pagination_offset', 'pagination_limit', 'pagination_count_total', 'pagination_reverse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ibc_core_connection_v1_connections" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pagination_key' in params:
            query_params.append(('pagination.key', params['pagination_key']))  # noqa: E501
        if 'pagination_offset' in params:
            query_params.append(('pagination.offset', params['pagination_offset']))  # noqa: E501
        if 'pagination_limit' in params:
            query_params.append(('pagination.limit', params['pagination_limit']))  # noqa: E501
        if 'pagination_count_total' in params:
            query_params.append(('pagination.count_total', params['pagination_count_total']))  # noqa: E501
        if 'pagination_reverse' in params:
            query_params.append(('pagination.reverse', params['pagination_reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ibc/core/connection/v1/connections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200107',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
